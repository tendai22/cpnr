# Register

Register|Description  
 |--|--|
 IP|インストラクションレジスタ。現在実行中のセカンダリワードの中で次の命令のアドレスを保持する。
 WA|ワードアドレスレジスタ。現在実行中のキーワードのアドレス、または、現在のキーワードのボディ位置の最初のコードのアドレスを保持する。
 CA|コードアドレスレジスタ。
 RS|リターンスタックレジスタ
 SP|スタックポインタレジスタ
 PC|プロセッサのプログラムカウンタレジスタ
 AH,AL|算術アキュムレータ(32bit)

Forth用仮想CPUに加え、アキュムレータのみを追加した。演算オペランドはスタック上, SP[0],SP[1], SP[2], ...とアキュムレータをオペランドとする。倍長整数演算も行うので、アキュムレータは32bitとするが、単長演算は下位16ビットで行う。

# Instruction

## 基本の枠組み

|Instruction|Description|
 |--|--|
 @A-B|レジスタAが保持するアドレスの位置の内容を、レジスタBにロードする(AからBへの16ビット間接フェッチ)。
 A=A+n|レジスタAを定数nだけ増やす。
 POP S-A|SプッシュダウンスタックのトップエントリをレジスタAにロードし、スタックポインタを更新する。
 PSH A-S|レジスタAの内容をSプッシュダウンスタックにロードし、スタックポインタを更新する。
 A-PC  |レジスタAの内容をPCにロードする。プロセッサはこの位置から次に実行する命令をフェッチする。
 JMP XX  |本ジャンプ命令の次のワードが保持するアドレスに無条件ジャンプする。

まずこれらの実現を考える。

* `mov @D,S`:  レジスタ(S)->メモリ転送(@D)
* `mov D,@S`:  メモリ->レジスタ転送
* `add D,nnn`:  レジスタ増減(nnnは定数)
* `pushs S`: スタックにレジスタSをプッシュ
* `pushr S`: リターンスタックにレジスタSをプッシュ
* `pops D`: スタックからレジスタDにポップ
* `popr D`: リターンスタックからレジスタDにポップ
* `mov PC,S`, `mov PC,@S`: PCへの転送は他のレジスタと同様に行える。
* `jmp nnn`: 無条件ジャンプ(絶対)
* `bnz nnn`: 条件ジャンプ(相対)

本当はバイトアクセスと文字列関連が必要だが、

* `movb @D,S`:  レジスタ(S)->メモリ転送(@D)
* `movb D,@S`:  メモリ->レジスタ転送

かな。

## 算術演算

算出演算は基本的にスタックトップで行う。つまり、SP間接参照である。Forthインタプリタを作るので当然である。演算種類もForthから取る。

## 機械語インストラクション

### mov命令(レジスタ、メモリ間転送)

レジスタは、IP, WA, CA, RS, SP, PC, AH, ALの8個、これをソース/ディスティネーションに配する。直接と間接の区分がソース、ディスティネーションにあるので、(1+3)+(1+3)の8ビットがオペランド記述に仕える。

機械語命令は16ビットで組む。上位8ビットをオペコード、下位8ビットを上記のオペランド指定に使う

cXXX, dXXX を機械語命令の範囲とする。この範囲に辞書・データは来ないだろう。

```
|15 -----   8| 7 | 6-4 |3|2-0|
| opcode(d1) |dst<br> 0/1|dst|src<br> 0/1|src|
```

 |Register| bit |
 |--|--|
 |IP|000|
 |WA|001|
 |CA|010|
 |AH|011|
 |AL|100|
 |RS|101|
 |SP|110|
 |PC|111|

## レジスタ増減

下位3ビットを符号付きオフセットとする。その上3ビットをレジスタ指定とする

```
|15 -----   8| 7 | 6-4 | 3-0 |
| opcode(d2) | 0 |dst|offset|
```

* offsetは-7から+7まで

## プッシュ、ポップ

```
|15 -----   8| 7-4 |4| 3-0 |
| opcode(d3) | 0 |0:push<br>1:pop|register|
```

## 分岐命令

最上位4ビットが"c"を全部割り当てる。

オフセット12bit ±2047番地への分岐可能

```
|15 --　12|11 -- --  0|
| opcode(cX) |offset|
```

## 算術演算命令

Forthの2項演算に割り当てる。dpan94(ANS X15)

### 2項演算子

 |operator|bit pattern|comments|
 |--|--|--|
 +|000000|
 -|000001|
 *|000010|(n1 or u1 n2 or u2 -- n3 or u3), 結果も単長なので上位桁が刈られる
 /|000011|
 /MOD|000100|
 MOD|000101|
 <|000110|
 =|000111|
 <>|000111|
 >|001000|
 AND|001001|
 OR|001010|
 XOR|001011|
 MAX|001100|
 MIN|001101|
 LSHIFT|001110|(x1 u -- x2), シフト数を指定できる
 RSHIFT|001111|(x1 u -- x2), シフト数を指定できる
 M*|010000|(n1 n2 -- d),単長同士で乗算して倍長の結果を得る。
 M+|010001|(d1 or ud1 n -- d2 or ud2), 倍長に単長加算
 U<|010010|
 U>|010011|
 U<|010100|
 U>|010101|
 SM/REM|010110|
 UM*|010111|(u1 u2 -- ud), 符号なし乗算
 UM/MOD|011000|(ud u1 -- u2 u3), udをu1で割り、商u3と剰余u2を返す。符号なし演算
 UM*|011001|(u1 u2 -- ud), u1 × u2 を返す。倍長。

 ### 単項演算子

 1+|011010|
 1-|011011|
 0<|011100|
 0=|011101|
 0>|011110|
 ABS|01
 INVERT
 NEGATE

### 3項演算子

 */||( n1 n2 n3 -- n4)
 */MOD
 M*/||(d1 n1 +n2 -- d2)
 
### リテラル

```
|15 -----   8| 7-0 |
| opcode(d5) | XX |

|15 -----   8| 7-0 |
| opcode(d5) | 00 |

```

`d5xx` は8ビットリテラル、これは単一ワードで0-ffまでのリテラルをスタックに置く。

`d600`は16ビットリテラル、これは次のワードの値をリテラルとしてスタックにおく。

