# C言語版Forth処理系を作るにいたったわけ

* C言語で書いたForth処理系を見た(ceForth)。なるほどこんな感じか。
* `narrowroad-m68k`開発で、アセンブリ言語で`WORD`, `NUMBER`, `FIND`, `.`を書くのが大変だった。Cなら楽に書けそうなのに。
* 組み込みCPUで使う場合、ベンダが提供しているフレームワークの中で動かすようにしたい。が、そのためにはC言語コンベンションに合致させる必要がある。アセンブリ言語で書いたForth処理系からC言語関数呼び出し機構を設けるよりも、C言語で書いたForth処理系の方が楽。
* 別のCPUに移植する、そのときも`WORD`, `NUMBER`, `FIND`, `.`を見知らぬターゲットCPUのアセンブリ言語で書くのか？
* `WORD`, `NUMBER`, `FIND`, `.`がForthで書けることは知っている。が自分の手元にはまだ書いたものがない。これをForthで書くことが次の作業だ。
* コロン定義で書く。書いてコンパイルしてテストして、を繰り返すためには、外部インタプリタが必要。そのためには動作する`WORD`, `NUMBER`, `FIND`, `.`が必要という「鍵は宝箱の中」状態。
* 今開発中の`narrowroad-m68k`上で開発を続けるのもしんどい。まだソースコード読み込みが完全に動作していない。いままでもエミュレータ上で開発してきたし、この段階で実CPU上で開発にこだわる必要もない。
* まず「鍵は宝箱の中」から脱出する必要がある。エミュレータ環境でForth開発。それもできるだけ機械語を使いたくない。
* C言語上で動作するForth処理系も見ている。スレッドコード実行系もわかってきた。エミュレータのイメージもある。

# 方針検討

* 外部インタプリタをC言語で書いて動作させる。`WORD`, `NUMBER`, `FIND`, `.`の組み合わせで書いた方がいいだろう。これら4機能をC言語で書いて組み合わせる。
* 実際に書いてみてうまく書けた。word, number, find,はそれぞれ関数呼び出しとして無限ループを組む感じ。
* 仮想機械をC言語でエミュレートする。仮想機械の機械語は、TIL記載のものをそのまま使おうか。ならばTIL記載の仮想機械レジスタアーキテクチャを使おう。
* 命令もそれを使えばよいか……まずTIL記載の内部インタプリタを構成する命令をベースに機械語命令を設計してみた。
* らしい命令体系を意識して組んだら、けっこうコード量が多くなりそう。これはやっていられない。
* `asxxxx`を眺めてみたが、これを改造して仕上げるにもかなり時間がかかりそう。今回は仮想機械アセンブラを作るのが目的ではない。
* 命令数を減らすんだ。直交性とか気にして「らしい機械語」を構成してもほとんどは使わないし。
* ならば、1プリミティブ1機械語命令でもいいじゃないか。`WORD`, `NUMBER`, `FIND`, `.`すべて1命令で動作する。全然仮想CPUっぽくないが、実処理はC言語で書くので、機械語命令の内部処理がどんなに複雑になっても構わない。ならば1命令の中に複雑なC言語で記述した処理を詰め込めばよい。
* 1命令がC言語の関数1個に対応しており、レジスタセットを保持する構造体のメンバを操作する。
* スレッドコード処理系(内部インタプリタ)はジャンプの連鎖だが、C言語は関数の呼び出しとリターンが基本、この違いはどう吸収するのかで混乱した。
* CPUのエミュレーションは、機械語命令実行の無限ループである。そこを中心に整理してようやく仕上がった。

### 処理系のイメージ

* 呼び出しはLinuxコマンド、引数にForth記述のForth処理系を渡す。アプリケーションは2つめの引数で渡す。
* メモリマップは決めとかないとなぁ。辞書領域、立ち上げ時の機械語プリミティブのみ、Forth処理系をコンパイルして辞書領域に追加する。この時点でまっとうなForth処理系ができあがる。
* 組み込みCPU上の場合、Forth記述のForth処理系(Core?だがCoreと言いたくないなぁ)はコンパイル済の辞書バイナリをフラッシュに書いておく。これを直接引いて使う。この辞書構成はクロスコンパイルになる。
* Coreをフラッシュに置き、アプリケーションをRAMに置く形態もあるので、辞書2つをリンクすることになる。
* C言語のメイン関数は、仮想CPUのレジスタ初期化と辞書初期化(RAMに読み込む場合とか、ホストからダウンロードするとか、FLASHイメージを参照する場合でも辞書ポインタの初期化は必要)
* Forthインタプリタの起動は無限ループワード`QUIT`のEXECUTEとなる。この辺はForth処理系の流儀。
* IPにQUITのアドレスを設定してC言語EXECUTEを仮想機械を起動して ... おっと、ここも自明ではなさそう。機械語のジャンプ命令を作ってQUITプリミティブ実行の無限ループを組むか。手を動かさないと分からない。
* 仮想機械の命令はForthプリミティブになる。Forthプリミティブを定義すると、C言語の`machine_code`関数とForth辞書のプリミティブ定義を自動生成するのがよさそう。primitive.cからプリミティブ関数名と機械語バイナリ(16bit integer)を生成して辞書ビルドする。
* ターゲットCPUごとにメモリマップは異なる(辞書アドレスは異なる)ので、辞書アドレスに合わせて辞書を構築できるクロス開発かな。

## おまけ

* ならば、組込みCPUフレームワークのデバイス制御ライブラリ関数呼び出しもこの1機械語命令にすればいいんじゃね？スタックポインタがC言語16bit integer変数なので、スタックでパラメータ渡してC言語関数の引数に渡すもできる。SPIやSDカード制御もこれでいけそうやな。
* いい感じのイメージができてきた。

