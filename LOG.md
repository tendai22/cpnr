# cpnr実装メモ

cpnr(A C Portable narrowroad interpreter)設計・実装の過程を記録し、C104同人誌ネタを集積する。

## 1プリミティブ1命令の仮想CPU

仮想CPUなので、PC, SPはじめForth処理系に必要なレジスタを持ち、PCをインクリメントしながら、「機械語命令」をフェッチ実行するエミュレータを作る。

最初はTILの仮想CPUの命令をそのまま実現しようかと思ったが、ソフトCPUなので、機械語のビットパターン構成を持つ必要はない。ビットパターン構成はハードウェア上の制約によるからである。

また、メモリとレジスタ間の転送もこだわらなくてよい。スタック経由でのデータのやり取りがメインなので。

ここまで考えて、**Forth1ワードを1機械語命令**としてもよいのではないかと思いつく。こうすることで、プリミティブはすべて、2命令(プリミティブを構成する命令一つとNEXT命令の2つ)で実現できる。

各機械語命令はC言語で記述できる。加算減算プッシュdropのような単純なワードも、`ACCEPT`(行入力)、`WORD`(空白文字でワードを切り出す)、`FIND`(ワード文字列で辞書を検索し、定義の有無を探す)、`NUMBER`(ワードをバイナリ数値に変換する)もすべてC言語で記述できる。

最初はC言語多めでForth処理系を作り上げてから、C言語部分をスレッドコード化(コロン定義化)して減らしてゆく際も、プリミティブ単位でスレッドコード化すればよく、移行の管理もやりやすい。

機械語命令化するワードを以後、プリミティブと呼ぶ。プリミティブは2種類ある。最後までプリミティブのままのワードと、最初はC言語命令だが、最終的にはコロン定義で置き換えられるものである。

#### 最終的にプリミティブのままのもの

他の実CPUに移植する際にはターゲットCPUの機械語命令で表現することになるもの。

1. 内部インタプリタ(NEXT,RUN,COLON,SEMI,EXECUTE)  
2. 加減乗除・ビット演算
3. スタック操作(PUSH,DROP,ROT, ...)
4. メモリアクセス(!, @, C!, C@)
5. 文字列処理(.")、メモリ転送(CMOVE, ...)
6. 出力処理(# #S <# #> ...)、入力(KEY, ?KEY)
7. アボート(ABORT)...大域ジャンプ機能、C言語でsetjmp/longjmn使う部分

#### 最終的にスレッドコード化するもの

コロン定義で再定義される。ターゲットCPUに「移植」せずともそのまま利用可能となる。

5. コロン定義(コロン、セミコロン、IMMEDIATE)
7. 定義語(CREATE, VARIABLE, CONSTANT)、
6. 制御構造(IF ELSE THEN, DO WHILE, ...)
8. 外部インタプリタを構成する単語(ACCEPT, WORD, FIND, NUMBER)
9. 外部インタプリタ自身(QUIT)

## 外部インタプリタ、内部インタプリタ、仮想CPU

外部インタプリタは当初C言語で記述する。ACCEPT, WORD, FIND, NUMBERに相当する処理をC言語で記述し、外部インタプリタはそれらを使ってループを構成する。

コードを書きながら感触を見て組んだ結果として、

    monitor ⇒ 外部インタプリタ ⇒ EXECUTION 
    ⇒ 仮想CPU実行 ⇒ debugger

とした、仮想CPU起動の前処理として辞書検索して得たxt(Execution Token)をスタックに載せておいてEXECUTEプリミティブのコード部のアドレスをPCに入れた状態で仮想CPU実行を開始する。

簡単なプリミティブなら1命令実行後NEXTを実行して終わる。複雑なプリミティブならそれなりにスタック操作したりする。スレッドコード部分なら、COLON命令のあとスレッドを構成する各ワードを実行し最後にSEMIを実行して呼び出し元に戻る。

最上位はmonitorである。基本的にrun命令`...`(ピリオド3つ)しか受理しない。実ハードではコンパニオンCPU内部のプログラムとなることを想定している。シリアルのダウンロード、ブレークポイントの設定機能が入る予定。

外部インタプリタ内部ではC言語記述の処理を実行し、最終的には辞書上のコードをスタックに積んだ状態で仮想CPUが動き始める。

仮想CPU内部では、命令のフェッチ・実行の合間にブレークポイント(予め登録しておいた仮想マシンアドレスとPCを比較し、同じであれば停止する)、HALT機械語命令を実行したところでいったん仮想CPU実行(do_machine)を終了し戻る。C言語記述の外部インタプリタは、次の実行サイクルを開始し、WORD/ACCEPTの実行から始める。

## 最初の立ち上げ

* monitor, 外部インタプリタ, EXECUTION, 仮想CPU実行,はそれなりに組んでおく。
* 仮想CPU実行は常時シングルステップとして、デバッガを呼び出す。
* デバッガは仮想CPUレジスタダンプとスタックダンプのあと、キー入力待ちとなる。キー入力するとデバッグを抜け、次の機械語命令実行に回る。
* 外部インタプリタ最初はWORDとEXECUTEのみを実装する。NUMBERはスタブ、FINDは常にテストワードのxtを返すスタブとする。
* 辞書エントリは1種類テストワードのみ、機械語命令を複数並べ、最後にNEXTを置く。

## WORD

WORDプリミティブのコードをC言語で書いている。入力ストリームの定義と設計が問題になった。

* `WORD`が現在読み込んでいる文字は`BLK`, `>IN`の2変数で決まる。
  + `BLK` == 0ならメッセージバッファ`S0`中のオフセット`>IN`の文字
  + `BLK` != 0なら、`BLK BLOCK >IN @ +`の位置の文字。`BLK`はブロック番号を保持する変数。`BLOCK`でブロックバッファ上に該ブロックの内容を読み込み、ブロックバッファ先頭のアドレスを返す。そこにオフセット`>IN`を足したアドレスがカレントポインタとなる。

この場合、入力メッセージバッファ`S0`(データスタック最後尾の次、昔のForthではデータスタックのすぐ上位に入力メッセージバッファを置いた)の有効長、ブロックバッファの残り文字数が明示的に表れてこない、がこれは必ず必要になる。何らかのシステム関数(例えば`getchar`)の内部で管理するのが適切だろう。末尾に達したらEOFを返す。Forthの場合は、バイト0を返すというのでよさそうだ。

EOFを返した時に入力ストリームを再初期化する必要がある。以前のnarrowroad-m68kでは`getchar`内部で行おうとしていたが、これは外に出した方がよさそうだ。

ロジックは「EOFが来たらキー入力を入力メッセージバッファに読み込み`>IN`をゼロに、残り長さを`getchar`内部管理の変数にセットする」とする。

ブロックバッファからソースコードを読み込んで解釈実行するのが`LOAD`であるが、これは入れ子で呼び出される。あるブロックの解釈が終わると、`LOAD`コマンドの次に実行を移す。とすると、`LOAD`のネスティングを管理せねばならないが、さてどうするか？

データスタック上でネスティングを管理することが可能かどうかよくわからない。ブロック間でデータスタックにものを置かないルールを課せばなんとかなるかもしれない。

個人的にはブロックバッファは使うつもりがないので、初期立上では内部バッファを読み切ったらキー入力としましょう。あと、`S0`と`PAD`はHERE+36byteと。

内部バッファ、エミュレータではファイル引数を読み込んで入力ストリームにつなぐ、実機ではFLASH領域のアドレス。

ACCEPTが、EOFが返ったあとのリダイレクト(`getchar`が次のデータを読み込めるようにする)。

プロンプトは、キー入力の入力バッファすべてを読み切って空になったときにその行に出す。OK出して改行、ユーザ入力は次の行の先頭から見える。となっているようだ。

