# cpnr実装メモ

cpnr(A C Portable narrowroad interpreter)設計・実装の過程を記録し、C104同人誌ネタを集積する。

## LOG.md 開始(4/1)

エイプリルフール開始だが別に嘘は入れていない。

## 1プリミティブ1命令の仮想CPU

仮想CPUなので、PC, SPはじめForth処理系に必要なレジスタを持ち、PCをインクリメントしながら、「機械語命令」をフェッチ実行するエミュレータを作る。

最初はTILの仮想CPUの命令をそのまま実現しようかと思ったが、ソフトCPUなので、機械語のビットパターン構成を持つ必要はない。ビットパターン構成はハードウェア上の制約によるからである。

また、メモリとレジスタ間の転送もこだわらなくてよい。スタック経由でのデータのやり取りがメインなので。

ここまで考えて、**Forth1ワードを1機械語命令**としてもよいのではないかと思いつく。こうすることで、プリミティブはすべて、2命令(プリミティブを構成する命令一つとNEXT命令の2つ)で実現できる。

各機械語命令はC言語で記述できる。加算減算プッシュdropのような単純なワードも、`ACCEPT`(行入力)、`WORD`(空白文字でワードを切り出す)、`FIND`(ワード文字列で辞書を検索し、定義の有無を探す)、`NUMBER`(ワードをバイナリ数値に変換する)もすべてC言語で記述できる。

最初はC言語多めでForth処理系を作り上げてから、C言語部分をスレッドコード化(コロン定義化)して減らしてゆく際も、プリミティブ単位でスレッドコード化すればよく、移行の管理もやりやすい。

機械語命令化するワードを以後、プリミティブと呼ぶ。プリミティブは2種類ある。最後までプリミティブのままのワードと、最初はC言語命令だが、最終的にはコロン定義で置き換えられるものである。

#### 最終的にプリミティブのままのもの

他の実CPUに移植する際にはターゲットCPUの機械語命令で表現することになるもの。

1. 内部インタプリタ(NEXT,RUN,COLON,SEMI,EXECUTE)  
2. 加減乗除・ビット演算
3. スタック操作(PUSH,DROP,ROT, ...)
4. メモリアクセス(!, @, C!, C@)
5. 文字列処理(.")、メモリ転送(CMOVE, ...)
6. 出力処理(# #S <# #> ...)、入力(KEY, ?KEY)
7. アボート(ABORT)...大域ジャンプ機能、C言語でsetjmp/longjmn使う部分

#### 最終的にスレッドコード化するもの

コロン定義で再定義される。ターゲットCPUに「移植」せずともそのまま利用可能となる。

5. コロン定義(コロン、セミコロン、IMMEDIATE)
7. 定義語(CREATE, VARIABLE, CONSTANT)、
6. 制御構造(IF ELSE THEN, DO WHILE, ...)
8. 外部インタプリタを構成する単語(ACCEPT, WORD, FIND, NUMBER)
9. 外部インタプリタ自身(QUIT)

## 外部インタプリタ、内部インタプリタ、仮想CPU

外部インタプリタは当初C言語で記述する。ACCEPT, WORD, FIND, NUMBERに相当する処理をC言語で記述し、外部インタプリタはそれらを使ってループを構成する。

コードを書きながら感触を見て組んだ結果として、

    monitor ⇒ 外部インタプリタ ⇒ EXECUTION 
    ⇒ 仮想CPU実行 ⇒ debugger

とした、仮想CPU起動の前処理として辞書検索して得たxt(Execution Token)をスタックに載せておいてEXECUTEプリミティブのコード部のアドレスをPCに入れた状態で仮想CPU実行を開始する。

簡単なプリミティブなら1命令実行後NEXTを実行して終わる。複雑なプリミティブならそれなりにスタック操作したりする。スレッドコード部分なら、COLON命令のあとスレッドを構成する各ワードを実行し最後にSEMIを実行して呼び出し元に戻る。

最上位はmonitorである。基本的にrun命令`...`(ピリオド3つ)しか受理しない。実ハードではコンパニオンCPU内部のプログラムとなることを想定している。シリアルのダウンロード、ブレークポイントの設定機能が入る予定。

外部インタプリタ内部ではC言語記述の処理を実行し、最終的には辞書上のコードをスタックに積んだ状態で仮想CPUが動き始める。

仮想CPU内部では、命令のフェッチ・実行の合間にブレークポイント(予め登録しておいた仮想マシンアドレスとPCを比較し、同じであれば停止する)、HALT機械語命令を実行したところでいったん仮想CPU実行(do_machine)を終了し戻る。C言語記述の外部インタプリタは、次の実行サイクルを開始し、WORD/ACCEPTの実行から始める。

## 最初の立ち上げ

* monitor, 外部インタプリタ, EXECUTION, 仮想CPU実行,はそれなりに組んでおく。
* 仮想CPU実行は常時シングルステップとして、デバッガを呼び出す。
* デバッガは仮想CPUレジスタダンプとスタックダンプのあと、キー入力待ちとなる。キー入力するとデバッグを抜け、次の機械語命令実行に回る。
* 外部インタプリタ最初はWORDとEXECUTEのみを実装する。NUMBERはスタブ、FINDは常にテストワードのxtを返すスタブとする。
* 辞書エントリは1種類テストワードのみ、機械語命令を複数並べ、最後にNEXTを置く。

## WORD

WORDプリミティブのコードをC言語で書いている。入力ストリームの定義と設計が問題になった。

* `WORD`が現在読み込んでいる文字は`BLK`, `>IN`の2変数で決まる。
  + `BLK` == 0ならメッセージバッファ`S0`中のオフセット`>IN`の文字
  + `BLK` != 0なら、`BLK BLOCK >IN @ +`の位置の文字。`BLK`はブロック番号を保持する変数。`BLOCK`でブロックバッファ上に該ブロックの内容を読み込み、ブロックバッファ先頭のアドレスを返す。そこにオフセット`>IN`を足したアドレスがカレントポインタとなる。

この場合、入力メッセージバッファ`S0`(データスタック最後尾の次、昔のForthではデータスタックのすぐ上位に入力メッセージバッファを置いた)の有効長、ブロックバッファの残り文字数が明示的に表れてこない、がこれは必ず必要になる。何らかのシステム関数(例えば`getchar`)の内部で管理するのが適切だろう。末尾に達したらEOFを返す。Forthの場合は、バイト0を返すというのでよさそうだ。

EOFを返した時に入力ストリームを再初期化する必要がある。以前のnarrowroad-m68kでは`getchar`内部で行おうとしていたが、これは外に出した方がよさそうだ。

ロジックは「EOFが来たらキー入力を入力メッセージバッファに読み込み`>IN`をゼロに、残り長さを`getchar`内部管理の変数にセットする」とする。

ブロックバッファからソースコードを読み込んで解釈実行するのが`LOAD`であるが、これは入れ子で呼び出される。あるブロックの解釈が終わると、`LOAD`コマンドの次に実行を移す。とすると、`LOAD`のネスティングを管理せねばならないが、さてどうするか？

データスタック上でネスティングを管理することが可能かどうかよくわからない。ブロック間でデータスタックにものを置かないルールを課せばなんとかなるかもしれない。

個人的にはブロックバッファは使うつもりがないので、初期立上では内部バッファを読み切ったらキー入力としましょう。あと、`S0`と`PAD`はHERE+36byteと。

内部バッファ、エミュレータではファイル引数を読み込んで入力ストリームにつなぐ、実機ではFLASH領域のアドレス。

ACCEPTが、EOFが返ったあとのリダイレクト(`getchar`が次のデータを読み込めるようにする)。

プロンプトは、キー入力の入力バッファすべてを読み切って空になったときにその行に出す。OK出して改行、ユーザ入力は次の行の先頭から見える。となっているようだ。

## FIND

 FINDの動作を確認するためには、辞書のバイナリイメージが必要である。辞書ファイルをアセンブリ言語に変換し、アセンブラ(*.s)とバイナリダンプ(*.Xファイル生成)ツールを作成した。

 辞書には、コードワード、しかも1機械語命令だけを含むコードワードを入れた。これを用いてC言語で外部インタプリタを作成し、ソースコードをコンパイルしてコロンワード(スレッドコード)を生成できるようにする。これが次の目標である。

 辞書エントリのリンクをたどって文字列比較するところは平明だった。strncmpが使えることは見通しの良さを得た。

 xt, 実行トークンの定義で迷った。辞書エントリのコードフィールドのアドレスを含むワードなのか、それともその中身のワード(そこに間接ジャンプする)のかである。結局TIL本の例のコードを見返した。

    Location   Mnemonic Instruction  Comment  

    0140       COLON   PSH I -> RS  
    0142               WA -> I  
    0144               JMP         ; Jump to NEXT  
    0146               0104          

    0100       SEMI    0102        ; Code address of SEMI  
    0102               POP RS -> I  
    0104       NEXT    @I -> WA  
    0106               I = I + 2  
    0108       RUN     @WA -> CA  
    01OA               WA = WA + 2  
    010C               CA -> PC  

    0050               7E          ; Dictionary  
    0052               XE          ; header  
    0054               LA          ; for EXECUTE  
    0056       EXECUTE 0058        ; Code address of  EXECUTE  
    0058               POP SP -> WA
    005A               JMP         ; Jump to RUN
    005C               0108  

`EXECUTE`のところ、スタックトップのワードの値は、RUNの先頭でそのアドレスを取り出しそこにジャンプする。つまり、辞書エントリのコードアドレスをスタックに積めばよいことが分かる。

    STAR(code_addr(entry));

ではなく、

    code_addr(entry);

をスタックに積めばよい。

## RUNが違うのではないか?→やっぱり違わない！

do_executeが最初動かなかった。1回余分にポインタを手繰ってしまっていた。

xtが次に実行するワードのコードフィールドなので、１ワード実行後、次のワードhaltをスレッドコード的に実行させようと考えた。それで、xtをipに入れたらよいと思っていた。

ユーザ変数HALTにxtを置くようにしていたので、ユーザ変数HALTの値をipに入れればよいのだろう。

        cx->ip = STAR(HALT_ADDR);

と考えたのだが、これで実行すると、機械語先頭をアドレスとしてフェッチ後飛び込んでしまった。

もう1回、スレッドコード実例も見ながら考え直した結果、「ipは、次に実行するワードのコードフィールドを指すアドレスを置いた場所を指している」のだった。

今の場合、たまたま、ユーザ変数HALTにxtを置いており、その置き場のアドレス、つまり、HALT_ADDRをipに入れればよいのだ。STARででレファレンスするのではなく、HALT_ADDRを直接ipに入れておく。内部インタプリタNEXTでは、IPの指す先にある「次のワードのCAのアドレス」を取り出して、その指す先にジャンプするので動作する。最初、TILの記述が間違っていると思ったのだが、そんなわけはない。間違っていたのは、私のdo_executeの作り方だった。久々に「mallocにバグ無し」という名言を思い出したことだった。

    void do_execute (context_t *cx)
    {
        // start inter interpreter
        cx->wa = do_pop(cx);
        // code of m_run(cx);
        cx->ca = STAR(cx->wa);
        cx->wa += 2;
        cx->pc = cx->ca;
        cx->ip = HALT_ADDR;
             // ipはxtの置き場を指すようにする。
             // それはアドレスHALT_ADDRだ。
        // do infinite loop
        do_machine(cx);
    }

do_machineはm_halt命令を実行するとdo_machne内の無限ループを抜けて戻ってくる。ワード"halt"(機械語命令m_haltだけを実行する)を定義して、そのコードフィールドアドレスをユーザ変数HALTに入れてあるので、これで動作する。

    1016 04     .head "halt"
    1017 68
    1018 61
    1019 6C
    101A 74
    101B 20
    101C 1008     .dw    entry_000
    101E 1020     .dw     .+2
    1020 C001     m_halt
    1022 C003     m_next

ユーザ変数HALTの値置き場のアドレスは、400A番地(マクロHALT_ADDR)である。ここには101Eが入っている。

    IP:400A番地の内容(101E)をWAに代入
    WA:101E番地の内容(1020)をCAに代入
    CA:1020番地にジャンプ(== CAをPCにmoveする)

とNEXTは動作する。

これで内部インタプリタも動作することが分かった。コロン定義を実行させて初めて完結するが、最後のEXIT以外は大丈夫そうだ。

次はコロン定義が書けるようにする。':', ';'を定義するが、その前にCREATEを用意する。

コロン定義が書けるようにすると、C言語1命令1プリミティブの用意は終わり、いよいよコロン定義だけを用いてForth処理系を書きおろしてゆく。

## コロン定義のコンパイル

コンパイルを実現するために必要な処理は3つある。

* ワード2個、コロンとセミコロン
* mainloop(外部インタプリタ)の「ワード実行」を「コンパイル」に切り替える
* 即時ワード(IMMEDIATE)処理

## ワード実行とコンパイルの切り替え

これは変数`STATE`の値により切り替える。変数名を明示的に書くことはなく、`[`, `]`の定義中で参照・書き換えるようである。我々は`[`、 `]`をプリミティブ(機械語)とするので、内部インタプリタ内部とこの両ワード定義内で参照できればよいということになる。

内部インタプリタも`[`、 `]`もコロン定義するつもりなので、ユーザ変数を定義する。コロン定義中では、`_state`でアドレスを返すワードとしてプリミティブを用意し、以後、それを使用する。

プリミティブとしては、コロン、セミコロン内部で切り替えるところで始める。`[`、 `]`, ワード`STATE`はコロン定義でつくる。実体としてユーザ変数_STATE(アドレスSTATE_ADDR)を用意する。

## :(コロン)と;(セミコロン)

コロン定義では、do_createした後にSTATE_ADDRに1を書き込むだけである。

セミコロン定義では、SEMIの実行トークン(xt)を辞書エントリに追加した後でSTATE_ADDRに0を書き込む。

SEMIの実行トークンは起動時に変数SEMI_ADDRに入れておく。

## 内部インタプリタが動作しない

プリミティブ(opcodeのC言語記述)の間違いが多かった。

* opcodeが動作しない。これは機械語(do_machine)の誤り
* opcodeエントリの最初で機械語命令に飛ばない。
* 飛んでも停止しない...executeの戻り先に「機械語ルーチン」ではなく、「機械語ルーチンのアドレスを入れた場所」をIPに入れておかねばならなかった。

今回良かったのは、COLON, SEMI, NEXT, RUNの機械語命令をTILに記載のものがあり、迷ったらそれに立ち返ることで方向を見失わなかったことだった。辞書エントリのコードフィールドのアドレスは「機械語ルーチン」のアドレスだが、コロン定義の2番目以後のアドレスは、「ワードのコードフィールド」であること。これを見失って道に迷いかけた。narrowroad-68kではここを自分だけで考えて道を踏み外し、気が付けば直接スレッドになってしまっていた。今回も、executeで実行できないとき、「アドレスを機械語命令として実行しようとした」ため、NEXT, RUNのでレファレンスを外しかけてしまった。TILのコードを前に頭を冷やして対応することで間接スレッドで完遂することができた。

要点は、
* 辞書エントリのコードフィールドのアドレスは「機械語ルーチン」のアドレスだが、
* コロン定義の2番目以後のアドレスは、「ワードのコードフィールド」であること。  
  この先のワードをフェッチして、そこにジャンプするのだ。
* xt(execution token)は「ワードのコードフィールドのアドレス」であること。

コロン定義の最初のアドレス(コードフィールド)と２番目以後のアドレス(パラメータフィールド)は意味が違うのだ。本で何度も見ているこの文言だが、いざ自分でコードを書きデバッグすると簡単に道を失ってしまうことを体験できたのは収穫だった。

## コードフィールドに入れるルーチンアドレス

当初、opcodeとして、COLON, NEXT, RUNのコードワードを定義して、辞書ロード後にこの３ワードのxtをdo_findで見つけて、それをユーザ変数に代入していた。あとでコンパイルの際に、新しいワードのコードフィールドに書き込むためである。

新しいコードフィールドに書き込むアドレスはこれではいけない。これはdo_findで当たったアドレスを入れてはいけない。この3ルーチンは機械語ルーチンとしてワードエントリとは別物として扱うべき。

C言語版Forth処理系としては、辞書の中にこれら機械語ルーチンも含めておきたい。辞書バイナリと一体化して、バイナリロード１回で済ませたいからである。辞書バイナリは、最初3ワードが辞書エントリのとりつき口(LAST, H/HERE)としている以外はすべてエントリの列である。

EXECUTEはxtを用いて起動するので、辞書エントリだけしか呼び出せないと考える。定義語の定義でコンパイル時にCREATEの後にコードフィールドに書くアドレスにも要注意。DOES>の後ろのコードを実行させたいのだが、ここがトークンスレッドなので、m_colon命令を置いてそこを指すようにする必要がある。

NEXT,RUNを分けているのはそれが理由かもしれないという気がしてきた。定義語で新しいワードを作ると、そのワードのCFAにはm_colonを置いた場所のアドレスを置くが、その中でIPをIP+2してはいけない。スレッドコードは別の場所(おそらく、元の定義語のパラメータフィールド後半)にあるからである。m_colonとは別の機械語ルーチンが必要そうだ。

改めてみていると、そうでもないか。EXECUTEはNEXTを呼び出さずにRUNを呼び出している。あー、これはスレッドコード中から呼び出すからかな。RUNは間接参照ジャンプで、WAがCFAを指すアドレスを保持している前提で作られている。NEXTは、このCFAアドレスをIPの先から得る。すなわちスレッドコードの実行なのである。EXECUTEはスタック上からxtを得るからこうなっているのだろう。また、スレッドコード中にEXECUTEを含めることができるように、EXECUTEのアドレス自体には .+2の定数が置かれている。これはコードワードのCFAに置かれているものと同じ。

ちょっとわかってきたかな。

* NEXT: スレッドコードの次のトークンの実行(IPの先からxtをフェッチして、IPポストインプリメントしつつxtにジャンプ(==RUNと同じ))
* RUN: 機械語的間接ジャンプ(xtアドレスをWAに入れて飛び込む)
* COLON: IPをリターンスタックにプッシュして、新スレッドコードの先頭をIPに入れてNEXTへ
* SEMI: リターンスタックからIPに戻してNEXTへ

機械語ワードの最後はEXITと呼ぶが、これは、(機械語ルーチンの中で使わなかった)IPをWAに入れてRUNだな。こうして書き下してみれば単純明快なのだが、1度では肌になじまないのがこわいところ。今後のターゲットCPUの移植でまたハマるだろうがやむを得ないな。この原則を見返して道を踏み外さないようにしよう。

TILの仮想CPUでWA, CAレジスタがあるのが面白い。おそらく、CFAに置かれたルーチン(COLON==doLIST, doVAR, doCONSなど)は自分のパラメータフィールドを知るのだろう。WAが+2されているので、パラメータフィールドのアドレスはWAが保持している。doVAR, doCONSで変数の置き場所はここから知ることになりそうだ。

## 整理

内部インタプリタで整理する。

* word_mem(addr) -> STAR(addr)と改名した。ターゲットメモリのaddrの値を取ってくるのだが、星なので左辺値でもあり、STAR(addr)に代入できる。ワード単位の処理。ちなみにバイト単位の処理では、mem[addr]がそれに相当する。バイト実ポインタの取得も &mem[addr]と書く。今のところ、ワード実ポインタを得てバリバリワード配列処理をすることにはなっていない。

* :(colon), ;(semicolon)と、メモリpeek, poke (C@, C!, @, !)と加減乗除が少々あれば、インタプリタは全部かけるんじゃないかという気がしているが、ひとつ欲しいものがある。それは `DOES>`である。これは定義ワードで用いられる。コンパイル時にエントリを作る際の挙動だけでなく、出来上がったワードを実行するときの挙動も記述できるというものである。変数、定数、配列などもこれがあれば構成することができる。

## `DOES>`

    : FOO CREATE ..(1).. DOES ..(2).. ;

と書く。(1)部分が通常のコロン定義同様に、FOOの定義、FOOを呼び出したときに実行する内容である。FOOを使うときは、

    1 2 FOO BAR

のように描き、FOOの前の1 2がパラメータ((1)で使われるものもあれば、(2)で使われるものもある)で、FOOはそれを解釈してワードBARを作る。ワードBARを実行すると、そのたびに(2)の部分が実行される。

例えば、変数を定義するVARIABLEは、

    : VARIABLE CREATE ..(1).. DOES> ..(2).. ;

ある変数ZOTを定義するときは、

    VARIABLE ZOT

と書く。これでワードサイズの変数ZOTができる。

(1)の部分で、ZOTの中を作り、(2)の部分はZOTを呼び出したとき(使うとき)実行されるコードを決める。

変数の仕事は、

* 変数ZOTの値を確保する場所はパラメータフィールドである。
* ZOTを呼び出すと格納場所(パラメータフィールドのアドレス)を返す。

これだけである。参照と代入は@, !を用いる。

## `DOES>`の実装

コンパイル時動作と実行時動作を持つ定義ワードの構成方法。Forth Programmming Handbook に記載がある。以下示す。

<img src="img/020-structures-defined-by-using-does.png">

> 1. コンパイラは `DOES>`を実行します。`DOES>`のコンパイル時の動作は、定義される新しいワード(`DOES>`を含む定義ワードのインスタンス)のコードフィールドを設定するコードをコンパイルして、`(;CODE)`のコンパイルされたアドレスに続くセルを指すようにすることです。
> 2. `(;CODE)`のアドレスの後、`DOES>`は `DOES>`のランタイムコードへのサブルーチン呼び出しをコンパイルします。その後、コンパイラは新しい定義ワードのアドレスのコンパイルを終了します。(定義ワードのサブルーチン呼び出しの使用はシステムに依存します。しかし、`DOES>`のすべての実装は、定義ワードのデータ空間アドレスを失うことなく、`DOES>`のランタイムコードが定義ワードの高レベルコードを見つけられるように、定義ワードに何かをコンパイルします)。新しい定義ワードが実行されるとき、その最後のステップは、それが作成するエントリの実行トークンを、定義ワードの `DOES>`によって作成されたジャンプ・ツー・サブルーチンを指すように変更することです。
> 3. 新しい定義ワードによって作成されたインスタンスの 1 つが実行されると、仮想マシンは定義ワードのサブルーチン呼び出しにジャンプします。次に、サブルーチンコールは、CPU に依存する何らかの方法で、それ自体に続くセルのアドレスを保存し、`DOES>`の実行時コードにジャンプします。このコードは、サブルーチンリンケージからのアドレスを使って、定義ワードの実行トークンを見つけます。`DOES>`の実行時コードはまた、定義ワードのパラメータフィールドのアドレスをデータスタックにプッシュします。

`(CR)`のコードフィールドには、「スレッドコードを実行するルーチン」のアドレスが置かれる。スレッドコードを実行するルーチンなのだから、`COLON`に限りなく違いが、実行対象が、自ワードのパラメータフィールドではなく、元の定義ワードの`DOES>`の後ろ側という違いがある。

スタックトップにはワード`(CR)`のパラメータフィールドアドレスが置かれている。その前提で`DOES>`の後ろのスレッドが描かれている(`COUNT` `TYPE` の印字対象は`(CR)`のパラメータフィールドである 2 0D DAである)

```
1420 03     .head "MSG"
1421 4E
1422 54
1423 47
1424 20
1425 20
1426 XXYY   link
1428 XXXX   doList
142A XXXX   create
142C XXXX   dodoes  // (CR)コンパイル時の動作の終了
                    // 1428を(CR)のコードフィールドに書き込む
                    // SEMIをコンパイルして(CR)のエントリを締める
            doexit  // MSGのスレッドコードの終了
1428 142A   .+2     // code field (以下の機械語コードを実行)
142A C040   m_does  // DOES>の最初、
                    // WAを保存する(CR)のパラメータフィールドを
                    // 指しているので
                    // WAを使わずにdoLIST相当の処理を行う
                    // IPをリターンスタックに保存し、
                    // WAに142Cを入れてNEXTへジャンプする
                    // --> スレッドコード実行が始まる
142C XXXX   COUNT
142E XXXX   TYPE
1430 XXXX   exit
```

`DOES>`は即時ワードで、

* ワード`dodoes`をコンパイルする。
  + ワード`dodoes`は、
    * 生成中のワードのコードフィールドに1428を書き込む
    * 生成中のワードに`doexit`をコンパイルして締める
* ワード`doexit(or SEMI)`をコンパイルする
* .+2 をコンパイルする
* 機械語命令`m_does`をコンパイルする

以後の COUNT, TYPE, exitは通常のコンパイル処理で生成される。特に配慮は不要。

## 最小opcode

消しまくってERRORが出なくなるまで復活させる。

## base.f 作成スタート

ForthでForthシステムを書く、を開始した。Forthで必要なワードをopcodeで提供されるプリミティブを使い記述してゆく。

* 定数。メモリマップ、セルサイズCELLS, ユーザ変数(LAST, H, S0, STATE, BASE, HALT, COLON, SEMI, LITERAL, DOCONS)
  + LAST, H, S0, STATE, BASE: Forthプログラムの定番、外部インタプリタとコンパイル機能作成時に使う。
  + here, allot, last, immediate, `,`(comma)はこれを使い作成できた。
  + HALT, ワードhaltのxtを格納する、コンパイルで必要
  + COLON, SEMI, LITERAL, DOCONS: コンパイルに辞書エントリ(スレッドコードのリスト)に書き込む際に用いる。毎回文字列から辞書引くのもあれなので、それぞれユーザ変数にxt(またはコードフィールドに書き込むアドレス)を保持しておく。
* 制御構造
  + `<mark`, `<resolve`, `>mark`, `>resolvc`: 制御構造のジャンプ(スレッドリスト内での前後移動のオペランド書き込みに用いる。
  + if-then-else: mark/resolveワードを作っておけば、以前作ったこともありスムーズに動作させることができた。
  + do ... loop: これは難儀した、以下、記録を残しておく。

## do ... loop の作成

リターンスタックにループ変数を取る。末尾のループで、ループ変数の値とリミット値を比較して回るか抜けるかを決める。コンパイル時に、loop内部のジャンプ命令のオペランドを算出する。`<mark`, `<resolve`を doの定義、loopの定義で使う。

do ... loop はあるワードの定義中で使用する。そのワードのコンパイル中に

* do, i, loopの処理(i: ループ変数の値をスタックに載せる, loop:回るか抜けるか決める, 終了時のリターンスタック/データスタック後始末)を行うワードをコンパイルする。
* loop末尾からdoの次へのジャンプ命令とオペランドのコンパイル。オペランド計算をここで行うのも当然だが。

* ターゲットワードのコンパイル中に do, i, loop のxtをコンパイルしてしまうと、オペランド計算ができない。それだけはコンパイル中に「実行」する必要がある。
* do, loopでは、`<mark`, `<resolve`だけを実行し、他の xtをコンパイルする。
* iはとりあえずxtコンパイルでよいだろう。
* do, loopは即値属性を付けてコンパイル中に実行することとせざるを得ない。これで`<mark`, `<resolve`は実行できるが、これ以外のワード、リテラルはすべて「手でコンパイル」しなければならない。
* 手でコンパイル: `literal foo ,`がすべてのワードfooについて書き下ろす。これは大変面倒くさい。

do, loopを他のワードで書く方法はすでにあるはず。それを探してみる。

## do ... loop の実装例

eForthあたりかな。eForthは`FOR...NEXT`(NEXTはR@をデクリメントして0になれば抜ける)を使い、`DO...LOOP`系はない。

ふと思いついたのだが、ワード`(loop)`

    (loop) (limit iaddr index delta)

を作ればよさそう。limitはDO呼び出し前に置いたものをそのまま使う。LOOP系の中で、delta, index-addr (RSPを置く) を(実行時生成するようなコードをコンパイルして)、(loop)をターゲットワードにコンパイルする、その後ろに `compile jz <resolve`(jzをコンパイルしてオペランドを解決)すればよい。

    : (loop)         \ ( limit limit iaddr index delta -- limit flag )
        +            \ limit limit iaddr i+d
        dup rot      \ limit limit i+d i+d iaddr
        !            \ limit limit i+d
        swap >       \ (limit -1) if i+d > limit, (limit 0) if i+d <= limit 
        \ falling down to jz
        ;

    : loop  \ limit -- limit if loop remains | none if loop exits)
        compile dup         \ limit limit
        compile rsp         \ limit limit iaddr
        compile dup         \ limit limit iaddr iaddr
        compile @           \ limit limit iaddr index
        compile literal
        1 here ! cells allot   \ compile 1 as delta)
                            \ limit limit iaddr index 1 
        compile (loop)      \ limit -1|0
        compile jz
        <resolve
        compile r>          \ limit tors
        compile drop
        compile drop        \ discard index (at rsp) and limit
        ; immediate

かなり遅そう。C言語プリミティブで書いた方がよさそう。

## do ... loop デバッグ

かなり苦労した。がなんとかできた。

    : aho 3 1 do i . loop ;

が動くようになった。ちなみに

    : aho 3 1 do i loop ;

は動かない。loopに入るときは、doを出たときと同じスタックレベル(tosが 3)である必要があるためである。

* `do`, `loop`は、`<mark`, `<resolve` を呼び出し元ワードコンパイル時に実行せねばならないので、コンパイルしてしまってはいけない。これのために即値ワードにせねばならない。これ以外のワードはすべて`compile`を前に置く。
* `compile` は後ろのトークンをHに書き込む
* `r>`, `>r` は、rstackのpeekではなく、pushr/poprする。

## 即時ワードの実行の様子

即時ワードは、他のワードの定義中に実行される。COMPILEを使うとき、他のワードの定義に実行トークンを足してゆく。この時内部インタプリタが実行の主体である。一方で即時ワード自身の定義は、外部インタプリタがワード文字列から実行トークンを探し出して書き込んでゆく。

loopの定義では、前処理と後処理の間に jzワードを置かねばならない。jzワードを置いた次に`<resolve`を(他のワードのコンパイル中に)「実行」せねばならないので、loop自体を即時ワードとせねばならない。なんとなれば、ワードloopの実行トークンがターゲットワードのスレッド内に置かれてしまい、そのスレッドの中で実行したい`<resolve`が現れてこない。

`<resolve`以外のワードはすべて、ターゲットワード実行時に実行されるようにするために、それらワード全ての前に`compile`が置かれる。非常に見苦しい形になる。`if`, `eise`, `then`なら2ワード3ワードなので単純明快だが、`loop`のように10ワード以上も並ぶと分かりにくい。

`loop`１ワードだけをコンパイルし、かつ、条件付きジャンプを実現する方法として、`loop`の後ろに飛び先オペランドを置く、`loop`をオペランド付きワードとする方法もある。

今回は素直にcompile地獄で固めた。

## do ... loop 作り直し

最初のバージョンでは、limitをデータスタックに残し、indexだけをリターンスタックに置いていた。Forth79を見ると、limit, indexの2つともリターンスタックに置いてもよい、置くのが普通だ、と言っているように見えた。

> loop-sys: loop control parameters.  These include implementation-dependent representations of the current value of the loop index, its upper limit, and a pointer to a termination location where execution continues following an exit from the loop.

私の実装では、loop control parametersをリターンスタックに置いている。なので、limitもまとめておいても良さそうなので。

終端点のポインタもあり得るというのは面白い。上で書いたように、コンパイル中のスレッドコードでloopの次の位置を指す場所を使うこともありだろう。今回は、loopは即時ワードとして`<resolve`でブランチワードのオペランドを計算させているので不要だが、そういう手もあるとは考えていたし、実際に使うことがあると分かったのは収穫だった。

制御構造は

    if ... then
    if ... else ... then
    do ... loop
    begin ... until
    begin ... while ... repeat

まで作った。次に何を作るか。

## DOES> ... 定義語を定義できるようにしよう

定義語を定義するときは、

* 定義語を定義するときの手続き
* 新しくできた個々の定義語が実行されるときの手続き

の2種類があり、それをコロン定義するための仕掛けが `DOES>`である。

    : foo create ..(a).. does> ..(b).. ;

(a)の部分が foo xxx で xxxを定義するときに実行する処理で、(b)の部分が出来上がった xxx を実行するときの処理である。

例えば定義語 variable の場合、

    variable xxx

(a): 辞書上に名前xxxを持つエントリヘッドを作成し、1ワード分の空きを作る。  
(b): 1ワード分の空き(パラメータフィールド)のアドレスをスタックに積んで帰る。

である。

    : variable
        create cells allot
        does> ;

(b)部分のコードに入ってくる時点でスタックトップにパラメータフィールドのアドレスがプッシュされているので、`does>` 節で何も書かなくてよいとなっている。

    entry_123:
        .head "variable"
        .link entry_122
        .dw   do_colon
        .dw   do_create
        .
        .(a)
        .
        // DOES> part
        .dw   do_does
        .dw   do_semi        // end of part (a)
    does_execpart:
        .dw   do_colon
        .
        .(b)
        .
        .dw   do_semi

`does>`は即時ワードで、`do_does`, `do_semi`, `do_colon`を(その定義語のスレッドに)コンパイルする。

`do_does`は、その定義語の実行時にターゲットワードのコンパイル処理を行う。

* ターゲットワードの code fieldに、`does_execpart`アドレスを格納する

例えば、定数定義語 `constant`は、

    : constant
        create , does> @ ;

と書けるため、`create` の後、`h`はコードフィールドをスキップしてパラメータフィールドまで進めておく必要がある。

## `DOES>`: 設計とデバッグ

これも非常に難航した。文献で参考となるソースコードが見つからなかったので、仕様をさぐりながらのデバッグとなった。

例えば、定数を定義する定義ワード`constant`は、通常、以下の定義となる。

    : constant create ..(a).. does> ..(b).. ;

これを使って定数ワード`foo`を定義するときは、

    100 constant foo

ワード`foo`の辞書エントリを構築する際は、(a)パートに従い構築される。`foo`を実行するときは、(b)パートのスレッドコードを実行する。

* `constant`の辞書エントリは、通常のコロン定義のコンパイルにより作成される。
* `100 constant foo`により`constant`が実行されるときは、
  + `create`により辞書エントリヘッダが作られ、
  + 後ろに(a)パートのコンパイル、
  + `does>`の処理(コンパイル又は実行)、
  + (b)パートのコンパイルとなる。

* `constant`のスレッドコードは下記の1886以後のワード列である。`does>`を境に、(a)パートの終端処理(semi)を置き、(b)パートの先頭の処理を組み立てるので、`does>`は即時ワードとして、その中で`compile semi`(実際は `SEMI_ADDR @ here !`)、`compile colon`(これも実際は`COLON_ADDR @ here !`)を含めておく。

```
1878 .head [constant]
1882 1850  [link]
1884 1030  [code]
1886 17ee ..(a)パート
1888 14ea ..
188a 1838 ((does))
188c 103c (semi)
188e c039 m_startdoes   // 機械語命令、ワードfooのコードフィールドが
                        // このアドレスを指している。
1890 1030 (colon)
1892 10be ..(b)パート
1894 103c (semi)  
```

* (b)パートは、`foo`だけでなく、`constant`により定義されるワード全てで実行される。よって、個々のワードにスレッドコードのコピーを置くのではなく、`constant`の辞書エントリ中にコンパイルされた部分を皆共通で実行できるようにしたい。
* `foo`のコードフィールドは、(b)パートを指すアドレスを入れる。ここに先頭の`colon`を指すアドレス(上記の例で1890)を格納してもうまくいかない。この位置にはアドレスでなく、機械語命令を置く必要がある。
* 仮想機械語命令`m_startdoes`を新設した。この中で1890以後のスレッドコードを実行する準備をする。
* これまでのIPを保存する必要があるので、`colon`を最初に置く。通常のワード定義と同じようにする。
* 1892以後の(b)パートと、最後の`semi`は`constant`自体のコンパイルの流れで生成される。`does>`でこの部分に関与しない。というか、その流れを利用してそのまま使うようにする。

```
1896 .head [foo]
189c 1878  [link]
189e 188e  [code]   ; `constant`ワード定義の`m_startdoes`命令を
                    ; 指すアドレス
18a0 0064           ; 定数100はここ、パラメータフィールドに置かれる。
```

* `constant`が定義したワード`foo`のバイナリを示した。パラメータフィールドにはスレッドコードはなく、ただ定数1ワード置き場だけが確保されている。
* コードフィールドには、`constant`定義の(b)パートを実行するアドレスを格納する。`colon`を指すアドレスを入れてみたが動作しない。`foo`のコードフィールドの先は機械語命令を指さねばならないのだが、`colon`で、次に実行するスレッドコードの先頭はWAレジスタに入れて渡すのだが、`foo`から飛ぶ際にはWAレジスタには`foo`のパラメータフィールドの先頭を指している。ここは`does>`の(b)パートを指すようにしなければならない。

なんらかの繋ぎ処理を機械語命令で行う必要がある。よって、新しい命令`m_startdoes`を作成した。

    case 57: // m_startdoes
        do_push(cx, cx->wa);
        cx->wa = cx->pc + CELLS;
        goto do_run_label;

`does>`の(b)パートがコンパイルされ始める手前に`m_startdoes`命令を置き、その後ろに`colon`アドレスを置く。PC + 2 は`colon`アドレスで、`run`ルーチンに飛ぶ。`run`ルーチンでは、WAアドレスの指す先のワードを取り、そこにジャンプ(PCに代入)する。今の場合は、`colon`ルーチンにジャンプするので、以後、(b)パートのスレッドコード実行を開始する。

(b)パートに入ってくるときには、スタックトップに`foo`のパラメータフィールドアドレスを置く必要があるので、`do_push(cx, cx->wa)`を入れている。

これでようやく動作を始めた。

とりあえず、新規で作るワードはここまでとし、これから、既存のワードをForthに書き換えてゆく。外部インタプリタを構成する要素、`word`, `find`, `number`を作る。また、書式付き出力(Forth界隈では絵描き出力(picutured output)と呼ばれる)も、トレース情報出力時に`fprintf`書式出力に置き換えるために用意したい。

## 外部インタプリタ再考

base.f読み込み時はクロスコンパイル前提で、C言語仮想CPUで`:`, `;`を実行する。それ以外のプリミティブは最終的にはコロン定義で書き換える。
最後に`:`、`;`をコロン定義で書きあげれば、ターゲット環境でコロン定義が実行できるようになる。

ターゲット環境のコロン定義は、端末入力からしか生じないという前提でいったん組むことにした。

## ACCEPT

acceptはC言語仮想CPU環境では、fgetsを使って読み込むという制約を想定してもよいだろう。この場合acceptは単純になる。当初は、行編集(バックスペース)もサポートしない。UNIX環境の行ドライバの編集機能を使う。

下部構造でfgetsで読み込んだ行データはgetchの呼び出しで1文字ずつ行バッファ`pad`に置かれる。カウント付き文字列なので、1バイト目が文字数である。

## WORD

> * -TEXT: ( addr1 u addr2 -- f ) 文字列比較、一致すれば f == 0, 一致しなければ正(str1 > str2)または負(str1 < str2)。本実装では1 or -1とする。
> * WORD: ( c -- addr ) cを区切り文字として入力ストリームから読み込み、辞書エントリ末尾に置く。

辞書末尾に置くのは、あとでワード定義する際にそのまま辞書エントリのヘッドに仕えるからでしょう。

通常は、`BLK`(ディスクから読み込んでいる場合のカレントブロック番号)と`>IN`(入力バッファ)を使う。キー入力読み込みの場合は、1行を行バッファに読み込んで`>IN`にオフセット値を置く。wordでは、padの先頭バイトのカウントと、>INに格納されるインデックス値を入力ポインタとして使う。

WORDの置き先はhereの位置、次のワード定義の先頭とする。スタックに置き先のインデックスを保持するようにした。

WORDの返し値アドレスはhereである。ユーザ変数Hを動かすわけにはいかないので、WORDのスタック先頭(delimのすぐ上)にインデックスを置き、hereと足して格納先アドレスを計算する。

デバッグの際には要注意。32 word終了後に here 10 dumpと打ち込むと、せっかく作ったhereの文字列データが、`here 10 dump`のhere, dumpにより上書きされてしまい、wordの正常動作の結果が分からなくなる。コロン定義中で、accept, wordを呼び出し都度here 10 dumpするようにするとよい。テスト用ワード`wtest`を用意している。

## プリミティブ最小化

いくつか減らすことができた。ただし、ユーザ変数 LITERAL_ADDRが消せなかった。これを消すとdo_number_compileが動作しない。コンパイル用プリミティブアドレスの扱いはもう少し考えたい。

やはり、先に外部インタプリタを作り上げてから考えよう。その際にdo_number_compile, executeのコロン定義化のやり方も決めることになるだろうから。

## FIND

辞書検索ワードFINDを作る。辞書末尾の空き領域(`here`)のカウント付き文字列で辞書を検索し、エントリを見つけ出す。

まず、文字列比較`compare`を作る。単純にバイト単位の比較で作った。辞書構造的には空白でスタブを作って偶数番地アライメントを掛けてあるので、ワード比較でも構わないのだが、文字列も短く効率アップもそれほど期待できない割に面倒なのでバイト比較とした。

`compare`のデバッグのために、2ワード読んでカウント付き文字列を2つ並べるワードを作った。その後ろに`compare`をつなぐ。あと、デバッグ用にコマンドをたたくとそのワード文字列がhere領域を上書きしてしまうので、デバッグしたい状態を保存できない。デバッグ用の文字列は別にバッファを用意して、一時的にH_ADDR変数を書き換えて`word`が格納するバッファを別に取るようにした。

動き出してから`find`が1文字ワードを比較できない。調べると`compare`が比較をインデックス1から行っていた(do ... loopの初期値が1だった)。ちょっと雑なつくりをしてしまった。

あと、`find`のサポートルーチンとして、
* `link_addr`: エントリ先頭からリンクアドレスを掘り出す。
* `prev_link`: そのエントリの一つ前のエントリを手繰る
* `entry_name`: エントリの名前文字列を印字する。

を作り、これらのテスト用に

* lastから順にリンクを手繰り、エントリアドレスとエントリ名を印字するワード

を作った。

ここまで用意して`find`作成に臨んた。スタック操作が脳内で想像できないので、ステップごとにスタックダンプを入れて動かした。格好つけるよりは結局こちらのほうが早そうだ。

## NUMBER

文字列から数値に変換する。`sscanf("%d", &arg)`相当である。

文字出力の際に「一桁生成する」ワードを作ってそれを繰り返し呼ぶように作った。同様に、「1文字処理する==文字が数値1桁に変換できれば、累積値を10倍(正確には`base`進数なので`base`倍)してその巣値を足す処理をまず作る。

ものの本には`>NUMBER`という名前が付けられている。

「文字を数値1桁に変換する」は、要するに"0-9A-Za-z"を0始まりに変換することと思えばよい。この変換に`base`は出てこない。

## [CHAR]

こらえきれずに、`[char]`を作ることを思い立った。次のワードの先頭文字をスタックに積むワードであるが、これが全然動かない。`bl word`を実行すると次のワード文字列をhere位置に読み込むはずが全然ダメ。

いろいろ試してわかったことは、C言語版外部インタプリタで、do_wordが読み込みに使用しているサービス関数とbase.fで定義したwordが読み込む際に使用するPADバッファと>INインデックスが異なるからと分かった。そらあかん。

do_wordが使用する1文字読み込み関数と、wordワードが使用する1文字読み込み手段が同じものでなければならない。やはりdo_wordが使用する1文字入力関数を機械語プリミティブにして、wordワードもそれを使うように変更する必要があると思われる。

なかなか奥が深い。

## WORD作り直し

バッファ上をなめる(PADと>IN)のではなく、narrowroad-68kのようにgetchベースでwordを作り直す。

C言語版ではプリミティブm_getchとして
* スタックに1文字返す。
* ファイル終端で-1を返す。wordのワード切り出しはいったん終端となる。
* 呼び出した側でリダイレクトすることになる。accept中で、base.fファイル読み出しがEOFすると、行入力読み出しに切り替わる。

accept/getch/ungetch含めた使い方は以下の通り。

* acceptは外部ストリームから1行読み込み、pad[0]: 長さ、pad[1]以後文字列に置く。外部ストリームが尽きると、キー入力1文字をpadに置く。
* getchはpad-in行からカレントインデックス(>in)を読み込み返す。
* ungetchした文字があれば先にそれを返す。
* m_getchプリミティブはgetchを呼び出しスタックに積む。
* base.fのwordワード定義では、getchワードを使ってワードを切り出す。

コメント処理、wordの中で消し去る。

* '('のみのワードに遭遇したら、')'までを読み捨てる。
* '\'文字に遭遇したら、行末まで読み捨てる。

## accept/getline再考(24/5/14)

連休前に上記の状態であった。連休中は遊び惚けて、連休後は "Systems Guide to FigForth", "fig-FORTH INSTALLATION MANUAL" 和訳で３週間近く空いており、`cpnr`実装が脳内から抜け落ちてしまったので、リハビリでコードを見直した。

現状は、

* C言語版accept(do_accept)は、ファイルから1行読み続けるが、ファイルがなくなれば標準入力から1行読み取る。
* Forth版(base.f)acceptはgetchで1文字読み取る。getchはプリミティブ(opcode)定義である。
* getchのC言語実装は、PAD行入力バッファの`>IN`の位置から1文字返す。

ということで、C言語版とForth版でacceptの入力元がずれているところは解消されていない。ここを直して`[char]`が動くようにする。

方針は風呂の中で何度か考えていて

* getlineをプリミティブとしてaccept(C言語版/Forth版)を統一する。
* getlineプリミティブ(C言語版do_getline)は、「ファイルから1行読み続けるが、ファイルがなくなれば標準入力から1行読み取る」を入れる、実質的には、C言語版acceptの挙動を引き継ぐことになる。
* Forth版acceptはgetlineプリミティブで1行読み取り行入力バッファに入れる。
* C言語版accept(do_accept)もdo_getline関数で読み取り行入力バッファに入れる。ここで1回コピーが発生するが気にしない。
* 将来的にForth版getlineを作るが、その時はワードKEY(キー入力読み取り、機種依存・機械語ワード)で行入力処理を盛り込む。システム立ち上げ時にbase.fファイル読み込む場合も、getlineの中で入力先切り替えを行う。

で行くことにする。

## C言語版getline

do_getline関数をcfunc.cに作る。この関数自体はスタック対応でなく、C言語風に作ってある。

コマンド引数で指定したファイルを順次オープン、1行ずつ読み込み返す。

全引数のファイルをすべて読み込み終えると、端末からの１行入力を開始するとともに、プロンプトを出力する。

プロンプトは`[ ...(stack)... ] ok`の形式で、データスタックのデータを出力する。これはおおよそのForth処理系のスタイルに従った。

## 仮想機械プリミティブ m_getline

getlineは１命令１ワードで用意する。

    getline \ ( n addr -- -1 (ready)|0 (eof) )

バッファサイズと先頭アドレスを指定して呼び出す。読み出し結果がスタックに積まれる。読み込んだデータ自体はカウント付き文字列として addr 以下に展開される。

特定CPU用のコードを用意する場合は、このワードを用意する。別途、Forth版で、キー入力にのみ対応したバージョンは作成する予定である。

## accept

getlineを呼び出し１行分のデータを行バッファに取り込む。行末の `\r`, `\n`は0で書きつぶし、その分短くなった行の長さをバッファ先頭に書き込む。文字列自体はバッファの１バイト目から書き込む。

行バッファは`pad`アドレスを使っているが、本来は`pad`でなく`S0`を使うべきなので、内部的には、`#tib`(text input buffer)内のアドレスに取り込むように変更する。

リダイレクトは別ワードで対応する。ディスクブロックからの読み込みを指定すると、getline内で「外部からの読み込みを完了させ、キー入力からの読み込みに切り替える、という風にする予定である。

## word

wordは`pad`とインデクス変数`>in`の値を使って１ワード分を切り出し、辞書末尾`last`にコピーする。

acceptを呼び出し、連続して `word`を呼び出すことで1ワードずつ切り出すことができる。

```
: wwtest
   begin 
      begin >rest 0x48 .ps 0> not while 0x23 emit space accept repeat
      begin bl word while repeat
   0 until ;
```

と組むことで、行バッファにデータが残っている間は`word`で1ワードずつ切り取り、行バッファが空になれば`accept`で次の行を取り込むというループを組むことができる。テキストインタプリタの前半部分の処理が組めたことになる。

コメント処理: 

* `(`を見つけたら`)`まで読み飛ばす、
* `\\`を見つけたら行末まで読み飛ばす、
  
は未実装である。fig-FORTHの場合は、`(`、`\\`を辞書に登録して「読み飛ばすワード」として定義しているようである。C言語版テキストインタプリタでは、word内部で読み捨てている。ここでもその手で行くので、辞書に両ワードを登録し、Forth版テキストインタプリタを実装するまで動作確認はお預けとなる。

## `'`(quote)、`[char]`

またもや苦労させられた。

`'`(quote)は、すぐ後ろのワードのexecution tokenをスタックにプッシュする。ワード定義内で

    ' foo ,

と書き、fooのexecution tokenをそのワード中にコンパイルするように使う。

* `' foo` の部分は、`literal` と`fooのxt`の2ワードをコンパイルする。
* これらをあるワードの処理中で行う。
* ワード`'`は、「コンパイル中に実行する」ため、即値ワードとする。
* ワード`'`の定義中で、
  + 次のワードを読み込む(wordを使う)
  + 辞書を引く(findを使う)
  + 結果が得られたら、`literal`, `xtアドレス`の2ワードをhereに書き込みallotして変数hを進める。

ところがいろいろ迷うことになった。

`'`(quote)ワード中に ','を書くと、このワード自体の中に入力から読み込んだワードのxtが入ってしまうのではないか？とか。

実際に定義を書いてみて、あとで`last dd`で出来上がった定義を見るまでは、正しい記述はできなかった。けっこう混乱が見られた。

結局以下の感じになる。

```
: ' \ comma ... find address of next string in dictionary
  0x1090 , 
  bl word ( 0x58 .ps .hd cr ) 
  find 
  not if abort then 
  ( 0x58 .ps ) 
  , ( last 16 dump ) ; immediate
```

`0x1090`がみっともない。`literal`のxtである。`' literal ,`と書ければよいのだが、`'`の定義中でこうは書けない。取り急ぎ動作確認のため数値直書きとしたが、別途ユーザ変数でも切っておこう。`literal`はプリミティブとなるはずなので、`base.f`の最初から定義が存在する。`base.f`の最初では`find`も使えないので、ユーザ変数に取っておくしかないと思う。

辞書定義がない名前を指定すると、実行時にアボートする。仮想マシン版では`abort`中で`halt`プリミティブを呼び出している。あまりきれいではないが、C言語版テキストインタプリタはhaltで停止する。

ターゲット版では`longjmp`風にジャンプ命令を入れておくつもりである。

`[char]`も同様である。`bl word`でワードを切り出し、先頭文字をスタックに積む、実際は`literal` 先頭文字のASCIIコード値をそのワード中に埋め込む。

## 倍長整数と演算

数値入力を組む前に、倍長整数の四則演算を用意する。C言語版は全てプリミティブとして、C言語で`int32_t`/`uint32_t`型で計算する。

Forthでは倍長整数は32bitで、2ワード、スタックエントリ2個分を占める。スタック的には、先に low をプッシュしてから highをプッシュするので、アドレスの若い方に上位16ビット、後ろの方に下位16ビットが置かれる。つまり、ビッグエンディアンである。

まず、倍長整数をスタックに乗せられるようにする。C言語版テキストインタプリタの`do_number`を書き換える。

### numberの倍長対応

C言語版`number`は`fscanf`を使っている。Forthの`NUMBER`の仕様は

* `, . / * :`のいずれかを含む数字列は倍長整数に変換して2ワードスタックに乗せる。
* 倍長整数は、先にlow, 後でhighをプッシュする。したがって、スタック表記では、`0x12345678`を数値変換すると、


    [5678 1234 ] ok

となる。

* `BASE`を基数としてASCII文字を変換する。これは`fscanf`では実現は難しい。手でASCII -> binary 整数変換を書いて、本ページ末尾に乗せる。

* `0x`を付けると16進数となる挙動、末尾が`H`なら16進数とみなす(fig-FORTHはそうなっているらしい)は導入したい。

結局、`number`の倍長対応において、`BASE`基数変換対応、区切り文字で倍長変換対応は、Forth版`number`で導入することにする。

現在のC言語版`number`では、単一長に収まらなければ倍長を置くこととした。これでForth版`interpret`ができるまでを乗り切る。

## 倍長演算

ネイティブコードで書く。opcode としてプリミティブとする。

Forth79仕様書によると、

```
D+|D-|D.|D.R|D0=|D<|D=|DABS|DMAX|DMIN|DNAGATE|DU<|
2!|2@|2CONSTANT|2DROP|2DUP|2OVER|2ROT|2SWAP|2VARIABLE|

```

がある。`D*`, `D/`がないのは、倍長×単長でやるためだろうか。

Starting-FORTHによると、`*/`が多倍長演算だそうだ。これで n3 を 1にすると単長×単長=倍長の結果が残せる。`NUMBER`を書く時の演算はこれで行けそうだ。

`Starting FORTH`には、`M+|M/|M*|M*/`がある。これらを作ることにする。

`M/`は結果が単長なので使いにくいので後回し。`M*/`があれば倍長×単長, 倍長÷単長が作れるのでこれで進める。

 |ワード|スタック|説明|
 |--|--|--|
 |D+|( d1 d2 --- d3 )|加算(プリミティブ)
 |D-|( d1 d2 --- d3 )|減算
 |M+|( d1 n1 --- d2 )|倍長+単長=倍長(プリミティブ)
 |M*/|( d1 n2 n3 --- t-result )|倍長d1×単長n2を3倍長で保持し、単長n3で割る、結果は倍長(プリミティブ)
 |D/|( d1 n2 --- d-result )|倍長÷単長で結果は倍長
 |D.|( d --- )|倍長整数を印字(C言語版プリミティブで始める)
 |D<|( d1 d2 --- flag )|`d1 < d2`で非ゼロ、`>=`でゼロ(プリミティブ)
 |DABS|( d --- d )|絶対値を取る(2の補数)
 |DNAGATE|( d --- d )|2の補数(ビット反転後1を足す)
 |DMAX|( d1 d2 --- d )|大きい方
 |DMIN|( d1 d2 --- d )|小さい方

プリミティブとして、`D+`, `M+`, `M*/`, `D<`を作る。他の演算子はコロン定義で派生させる。

> 単長の比較プリミティブが`>`であるのと逆なのがよろしくないが、とりあえずこれで行こう。

`D+`, `M+`, `M*/`, `M<`をプリミティブとして作った。

`bitnot`, `dnegate`, `m/mod`を作った。`m/mod`は結構大変。値をリターンスタックに保存して戻す。

## 数値出力の倍長対応

`#`が倍長数を扱うようにする。

* `/mod`を`m/mod`に変更する。
* `#s`の終了条件(被除数がゼロになるまで)を倍長数の0判定にする。
* `#>`で倍長数をdropする。

`.`は単長数。`d.`は倍長数を表示する。

`100000000 d.`の表示が`0 ok`だけになってしまった。悩んだが原因は `#field`の値が8で、表示幅が足りなかったことが原因だった。マイナス表示も含めて倍長数を使った数値表示が動き出した。

## 倍長演算の続き

|ワード|スタック|説明|
 |--|--|--|
 |D-|( d1 d2 --- d3 )|減算
 |D/|( d1 n2 --- d-result )|倍長÷単長で結果は倍長
 |DMAX|( d1 d2 --- d )|大きい方
 |DMIN|( d1 d2 --- d )|小さい方

すぐ実装できた。`d/`は`m/`と同じだった、ややこしい。

## number

倍長数が扱えるようになったので、いよいよ`number`実装に取り掛かる。

> `(number)` ... addr1 から始まる ascii テキストを BASE を基準に変換する。新しい値は倍長数d1に累積され、d2として残される。addr2 は変換できない最初の桁のアドレスである。NUMBER で使用される。

まず、数の文字列から正の倍長数を生成するロジックを作った。

文字1桁を数に変換する`#a2i`を作った。`base`を超えるとダメ、がまだ実装できていない。

rot でポインタを上げてインクリメントしておろすなど、スタックぐるぐるが多発した。

負の符号と、区切り文字の検出とスキップがまだ残っている。区切り文字を扱う場合はループ組み直しになる(`begin ... while ... repeat`では組めない)。難しい。

* d1 = d1 * 10 + nと
* addr1++

を分けて考えねばならなくなった。区切り文字では d1 = d1 * 10 + nしてはいけないが、ポインタはインクリメントせねばならない。

## Systems Guide to FigFORTHを参考にした

`(number)`を自分で組んでから、Dr. Chenの本を見直してみた。ずいぶんとシンプルにできている。参考に組みなおした。

自分で組んだものとDr. Chenの版を見比べると発見があった。

#### シンプルさは「呼び出し時の前提」を多く置くことで達成できている。

`(number)`の呼び出し時に、最初にアドレスポインタを無条件でインクリメントしている。このインタフェースならば、addrは文字列の先頭を指すのが普通だと思っていることに気づいた。

`(number)`が`number`からしか呼び出されない前提で考えるとこれでも構わない。実は、`number`で最初に補正しているわけでもないので、`number`も1バイト目は無視する挙動になっている。Forthの文字列が、カウント付き文字列なので、文字列をスキャンする場合1バイト目はスキャン対象ではない。なのでこれで不自由はないのだろう。

C言語文字列が脳内にしみついている私の場合、addrは文字列先頭を表す、表しているに決まっている、違うというのはないだろう、そういう感覚になっている自分に気づいた。かなり違和感があった。

#### Keep it Simple!の徹底

`(number)`を独立して使えるとあとで再利用できるので便利、そういう考えが自分にしみついている。そのことにも気づかされた。

面白い。これが50年前のプログラミングの感覚なんだ。

「あとで再利用できるので便利」でCharls Mooreの言葉を思い出す。Keep it Simpleのスローガンと同時に、汎用性あるインタフェースは冗長となるとして戒めていたことを思い出した。多分、私もKeep it Simpleまだまだ徹し切れていなかったのだろう。

#### コードを全部読まないと使えない

これは、「名前からコードの挙動にあたりを付けて読む」が通用しない世界であることを意味するのだろう。「文字列をバイナリ数値に変換するが、1文字目は読み飛ばす」というのは、`number`という名前では想像もつかない。コードを見て動かしてみて初めて分かる。

実は、私も動かしてみて初めて分かった。コードを読まないと分からない・コードを動かさないと分からないというのは、現代には通用しない特性だと思う。

普段、完全に覆われてシートベルト締めて安全装置付きのクルマをオートまで走らせているのと、安全装置なし、カバーなしでバイクにまたがって山道飛ばしているのと、それぐらい違う気がする。

それだけに、コードを隅から隅まで頭の中に入れて組む感覚が心地よい。全能感とコントロール感、場を全て把握している感覚はそれなりに心地よい。

## `?ERROR`の実装

`number`で、数字列として許されない文字に出会うとエラーでインタプリタ再スタートとなる。`?ERROR`を直接呼び出す、これも結構乱暴だ。まぁ、エクセプションもないからね。

Dr. Chenの本によると、ワードABORTを呼び出す。ABORTはQUITを呼び出す、という風にワードの連鎖となっている。つまり、IP呼び出しレベルでジャンプしている。ワードの呼び出しだが、リターンスタックをクリアすると実質的にIP呼び出しのネストもクリアされるので再スタート扱いになることを理解した。

スタートは3段階

* `COLD`: これが電源投入後のコールドスタート
* `ABORT`: データスタックポインタのクリア、数値変換基数を10に設定、サインオンメッセージ表示
* `QUIT`: インタプリタモード(`STATE`に0設定)、「リターンスタックをクリアして`INTERPRET`呼び出し」の無限ループ

テキストインタプリタが`ABORT`, `QUIT`という名前である理由が分かった。大域脱出なのだが、同時にメインループの始まりでもあるということだ。

## C言語版の実装を深めるか？

COLD, ABORT, QUITは最終的にForth記述版を作る。現在のテキストインタプリタはC言語で記述しており、仮想CPUのプリミティブでさえもない。ABORT, QUITをC言語版にするには最終的にはメインループ(C言語版テキストインタプリタ)に手を入れないといけない。大手術になるわりにはメリットが少ないので、Forth言語版ABORT, QUITを作るまでは手を出さないことにする。

## 最小プリミティブ版C言語仮想機械版Forth処理系

そろそろ辞書のアンダンプとロード機能を入れた方がいいだろう。引数で渡してRAM上に展開し、機械語プログラムを起動する。

スタック2つ、ユーザ変数領域、行バッファ、PAD(出力整形バッファ)はRAMの連続領域で動くようにしておく。マルチタスク版で動くようにしたい。

最初の初期化コード: RAM上に辞書イメージ/FORTH処理系が載っている前提で、IPを設定しておいてm_nextを実行する。飛び先はスレッドコード(COLD)でデータスタック、リターンスタックを設定する。

QUIT自体が無限ループとしてつくるので、これで終わり。EXIT的なものは存在しない。

## 文字列をつくった

`"`(double quote)をワードとして、コロン定義中で指定できるようにした。

## 循環参照

文字列を作ると、循環参照の問題が出てきた。

* `[compile]`は、`."`を呼び出している。
* `."`は、`[compile]`を呼び出している。

である。どちらかをプリミティブ(アセンブリ言語で書く)のは苦しいので、どちらかをベクタとすることとした。

いやいや、コロンセミコロンと一緒でしょう。コンパイルするワードは、最初はC言語プリミティブで書いておいて、のちに自分自身を再定義すればよい。最初のC言語プリミティブが動作するときには、`[compile]`自身は辞書に書き込まれない。ので、あとで未定義プリミティブになることもない。

* C言語版`[compile]`で、`."`をコンパイルする。
* 次にbase.fにForth版`[compile]`を書く。

結局、即時(immediate)ワードで、`[compile]`されないものはC言語版プリミティブで開始してもよいということだ。

## [compile]プリミティブ、文字列表示ワード`."`

`[compile]`プリミティブを準備し、文字列表示`."`を定義できた。

汎用の文字列取り込み・コンパイルワード`["]`を用意した。各種文字列ワード(abort"など)の最初に置き、文字列リテラル`sliteral`の構造を作り、スレッドコードに書き込む。

文字列表示の場合、あるワード定義で `." aho"`と書くと、そのワードの該当部分に、`sliteral + カウント付き文字列+count+type`が書き込まれている。

```
2612 .head [baka]
2618 25fa  [link]
261a 1030  [code]
261c 10d2 (sliteral)
261e 6103 (baka)    \ 3,'a','h','o',garbage
2620 6f68 (baka)
2622 25ee (count)
2624 1da6 (type)
2626 106c (semi)
```

C言語仮想機械はamd64アーキテクチャ上で動いているので、little-endianなのだ。このように、16bit wordのバイト順はCPUに合わせて決まる。今後、辞書をクロスコンパイルする際には、ターゲットがビッグエンディアンかリトルエンディアンかを指定して、それに合わせて辞書中のワードのバイト順をコントロールすることになるだろう。

## C言語版テキストインタプリタ再考

Forth版ワード中で `abort` を呼び出すことが出てくるので、テキストインタプリタ構造を再考した。

ターゲットCPUでつくることを考えると、スレッドコードで`abort`を呼び出すと、実際には`abort`のスレッドコード実行を開始する。この時、スタックポインタを巻き戻す。スレッドコード中でCPUのIPレジスタを直接触ることはしない・したくないので、スタックポインタを初期化するワード`sp!`, `rp!`をプリミティブとして用意する。

仮想機械命令として`trap`を用意した。テキストインタプリタ中の実行は以下のようになる。

* C言語実体は、PCの先をフェッチして機械語命令として1命令実行、実行後PCをインクリメント(2バイト分)、これの無限ループとなる。
* C言語テキストインタプリタはexecute関数で1ワードだけ実行する、を繰り返す。executeで1ワード実行後、halt命令を実行する。
* halt命令を実行すると、C言語仮想機械は無限ループから抜け、呼び出し元(C言語テキストインタプリタのexecute)に戻る。スタックなどをリセットせず、次のワード読み込み・辞書サーチ・実行に取り掛かる。
* trap命令とtrapワードを用意した。この機械語命令が実行されると、同じくC言語仮想機械は無限ループを抜け、リザルトコード-1を返す。
* 呼び出し側はexecuteのリザルトコードに-1が現れるので、C言語テキストインタプリタはスタックを巻き戻し初期化処理を行いループを再開する。またはlongjmpでループ最初に戻る。

なんとなく`halt`, `trap`命令を用意して、`abort`ワード中で`trap`ワードを呼び出せばよいではないかと思ったのだが、よく考えてみると、`abort`は行入力、解釈実行の無限ループである。ちょっと違うよね。ということで、Forth版テキストインタプリタの設計について考えねばならないことが分かった。

以下の方針で検討してみる。

* 最初`abort`は`trap`を呼び出すだけ。C言語版テキストインタプリタが実行されており、その中でテキストインタプリタ再初期化が起こる。
* Forth版`abort`が定義された瞬間に、以後定義される`abort`はインタプリタループそのものになる。スタックの初期化を行えばそれでよい。
* それ以前に定義したワード中の`abort`は古い定義のままなので、そのようなワードを呼び出すと、古い`abort`->`trap`が実行され、C言語版テキストインタプリタに戻ってしまう。

解決策:

* `trap`をプリミティブにする。
* 最初の定義は、ワード`trap`は機械語命令`m_trap`を実行するのみ。
* `abort`を定義する時点で、ワード`trap`の「中身を入れ替える」。今度はワード`abort`を呼び出すコロン定義のパラメータフィールドアドレスを挿しこむことになる。
* Forthから実行できるように、ワード`trap`はベクタ

Forthから切り替えを実行できるように、

* ワード`trap`はベクタ`'trap`を呼び出す。
* ベクタ`'trap`は変数として定義して、`@execute 'trap`で実行できる。
* 変数`'trap`の初期値は、ワード`trap`のexecution tokenとしておく。
* Forth版`abort`が定義されると同時に、変数`'trap`にワード`abort`のexecution tokenを代入する。これで Before ABORTのコードでも`abort`を呼び出すようになる。

## エラーチェック

Fig-FORTHのエラーチェックワードを調べてみた。

```
?COMP ... コンパイルエラー
?CSP ... スタック位置が`CSP`に保存された値と異なる場合にエラーメッセージ
?ERROR \ ( f n --- ) ... フラグfがtrueの場合にエラーメッセージを出す。
?EXEC  ... 実行しない場合にエラーメッセージを出す
?LOADING ... ロードしていない(ロード中でない)場合にエラーメッセージ
?PAIRS ... \ ( n1 n2 --- ) 制御構造のコンパイル中で使う
?STACK ... スタックが範囲外の場合
?TERMINAL ... \ ( --- f ) 端末のキーボードでbreakキーが押されたかどうかのチェック。今ならCtrl-Cだろう。
```

各種エラーワードは、フラグ(エラーかどうかの判定結果)とエラー番号を積んで `?ERROR`を呼び出す。

```
: ?ERROR  \ ( f n --- )
    SWAP IF ERROR ELSE DROP THEN ;
```

* `?ERROR`はフラグがtrue(非ゼロ)であれば`ERROR`を呼び出す。
* ゼロであればおとがめなし

```
: ERROR \ n -- in blk
    WARNING @ 0<    \ See if WARNING is -1,
    IF (ABORT)      \ if so, abort and restart.
    THEN
    HERE COUNT TYPE \ Print name of the offending word on top
                    \ of the dictionary.
    ."?"            \ Add a question mark to the terminal.
    MESSAGE         \ Type the error message stored on disk.
    SP!             \ Clean the data stack.
    IN @
    BLK @           \ Fetch IN and BLK on stack for the operator
                    \ to look at if he wishes.
    QUIT            \ Restart the Forth loop.
    ;
```

* `WARNING`のチェック。
* `WARNING`が負ならば`(abort)`
* `WARNING`が正であれば、ディスクページ中のエラーメッセージを番号で引いて表示する。
* ゼロであれば、現在のワード名の後にエラー番号を印字する。
* スタックを初期化後に`IN`, `BLK`の値(現在行情報)を置いて`QUIT`を呼び出す。
* ちなみに、`WARNING`の初期値は1である。

`QUIT`側ではスタックの上2つを使用していない。`QUIT`に来た時点でスタック2段が使われている状態になる。エラー後のソース調べには便利だよな。

我々の実装では、`IN`, `BLK`の値をスタックに置かずに、エラーメッセージにソース行位置情報を出力することにする。`getline`の中で行番号を残しているので、その値を表示する。

* `WARNING`をチェックし、負ならば`ABORT`
* 非負ならば「データスタック」「リターンスタック」「行番号」「ワード名」「メッセージ」を表示した後、データスタックをクリアして`QUIT`を呼び出す。

Forth版インタプリタが走り出してから、ディスクからプログラムを読み込む機能は今のところ考えていない。C言語版ならSDカードやシリアルフラッシュを使うのだろうが、Forth版でこれらへのアクセスルーチンを自分で作るのも腰が引けているのだ。

`(abort)`の中でベクタ`'trap`を実行する、でよいだろう。

## エラー番号とエラーメッセージ

* 面倒なので、各エラーチェック関数の中で文字列を作って渡すことにする。

## 再度まとめると

* エラーが発生すると、メッセージを表示・データスタッククリア・`QUIT`呼び出す。
* `QUIT`の最初でリターンスタックをクリアする。
* 1行読み込むごとに`INTERPRET`を呼び出す。
* `(abort)`は、Forthシステムを抜けて呼び出し元に戻るイメージ。

## 文字列系

とりあえず`."`を作ったが、ほかにも`ABORT"`とかいろいろあるようだ。Fig-FORTH/FORTH-79の規定をしらべてみよう。

```
."    \ Fig-Forth/Forth-79はこれのみ
```

いや本当にこれだけかい。"Programming Forth Handbook"には、

```
S"     \ ( --- count addr )
C"     \ ( --- c-addr )
ABORT" ( i*x flag --- ); ( R: j*x --- ) ... 
        \ flagが真なら文字列を出力しスタックをクリアしてタスクの
        \ アイドル動作に戻る。
```

が記載されている。上記エラー処理では、文字列の定義部分と印字箇所が別ワードなので、間を文字列でつなぎたいので、このワードは採用する。

## QUIT/INTERPRETデバッグ

FigForthベースで組んだ。

数字の1を入力すると動かない。ワードliteral/dliteralの意味が違っている。

コンパイル時には、スタック値nを16ビットリテラルとしてコンパイルする、である。

スレッドコード中のoperand付ワードではない。この2つがごっちゃになっている。

`word`, `find`の挙動が違っている。 `interpret` の挙動を手元の `word`, `find` に合わせている。一方で、`find`の文字列バッファを `last` から `here` に変えた。おかげで`'`(comma)も効かなくなった。難しい。

## quit の execute が動かない

C言語版のdo_executeの呼び出しと、Forth版interpretのexecute呼び出し時の違いを見る。

opcodeの m_executeがおかしかった。

TILのEXECUTEをよく見ておかないといけない。

EXECUTEは、IPにxtを代入してnextに行くというものではない。

```
0056            EXECUTE 0058 ; Code address of EXECUTE
0058            POP SP - WA
005A            JMP ; Jump to RUN
005C            0108
```

WAにxtを入れてからrunに飛ぶ。これと、IPの次の指し手がhaltになるようにして動作した。

```C
    case 7: // m_execute
        cx->wa = do_pop(cx);
        cx->ip = HALT_ADDR;     // ipはxtの置き場を指すようにする。
                            // それはHALT_ADDRだ。
        goto do_run_label;
```

スタックはおかしいが、とにかく、`: aho ." baka " ;`で定義した`aho`を実行すると文字列bakaが出力された。

実行結果は以下の通り。

```
quit

1 1+ aho
![0002 ]
FF00 8 "1 1+ aho"
0[0002 ]
1[0002 2CA6 ]
2CA6 1 "1"
2[0002 2CA6 ]
3[0002 2CA6 0000 ]
2CA6 01 31 20 69 74 20 00 00 00 00 00 00 00 00 00 00
7[0002 2CA6 0001 0000 0000 ]
8[0002 2CA6 0001 ]
0[0002 2CA6 0001 ]
1[0002 2CA6 0001 2CA6 ]
2CA6 2 "1+"
2[0002 2CA6 0001 2CA6 ]
3[0002 2CA6 0001 146C FFFF ]
4[0002 2CA6 0001 146C FFFF ]
5[0002 2CA6 0001 146C 0000 ]
6[0002 2CA6 0001 146C ]
baka [0002 2CA6 0002] ok
```

ちょっとまだおかしいか。`quit`で実行したのは`1+`までで、`baka`は`quit`抜けてC言語版テキストインタプリタで`aho`を実行して出力されたとみるべきですね。

```
quit

aho
![0002 2CA6 0002 ]
FF00 3 "aho"
0[0002 2CA6 0002 ]
1[0002 2CA6 0002 2CA6 ]
2CA6 3 "aho"
2[0002 2CA6 0002 2CA6 ]
3[0002 2CA6 0002 2C7A FFFF ]
4[0002 2CA6 0002 2C7A FFFF ]
5[0002 2CA6 0002 2C7A 0000 ]
6[0002 2CA6 0002 2C7A ]
baka [0002 2CA6 0002] ok
```

こちらはahoを`quit`/`interpret`ループで実行している。期待通りに動作している。ただ、1回実行すると抜けてしまうのは
おかしい。`HALT_ADDR`に充てているからかな。

```
1072 07       .head   "execute"
1073 65 78 65 63 75 74 65 20 20
107C 1064     .dw     entry_006
107E 1080     .dw     .+2
1080 C007     m_execute
1082 C003     m_next
```

この最後の `m_next` を `m_halt` にすればいいのかもしれない。`m_execute`/ワード`execute`の実体はターゲット版で機械語手書きとするのがよいのだろう。

いや、`quit`ルーチンの実行を継続するためには、`m_execute`の後ろは`m_next`であるべきですね。`HALT_ADDR`を消して再試行する。

`HALT_ADDR`を外したところ、コマンドを実行してもループから抜けなくなった。スタックはぼろぼろですが。これで先に進もう。

## `-find` の結果にc-addrが残る件

複数辞書の検索のために残すべき。Fig-FORTHでは、下請けワード`(FIND)`があり、

```
(FIND): ( c-addr dict-addr --- pfa len true | false )
\ A primitive. Search the dictionary starting at the address
\ on stack for a name matching the text at the address second
\ on stack. Return the parameter field address of the
\ matching name, its length byte, and a boolean true flag
\ on stack for a match. If no match is ppossible, only a
\ boolean false flag is left on
```

我々の実装では、

```
-find: ( c-addr --- 0 | xt 1 | xt -1 )
```

発見できなかった場合、`-find`の返し値にc-addrを残しておく。後続の`number`でc-addr文字列を使うので、これが便利なのだろう。辞書発見の有無フラグは、あとで1 or -1の値も使う(`compile` or `execute`の判断に)ので、`if`の前でdupして、`number`の前で`drop`することにした。

以上で、`accept`/`interpret`が動作しだした。

* 定数、
* ワード
* コロン定義

が動作する。`quit`内部で定義したワードも、当然ながら`quit`を抜けても残っている。

ただ、`abort`がかかったときに`quit`も抜けてしまうのが難点。機械語命令の`trap`を実行しており、`trap`はC言語版外部インタプリタからのワード実行をやめ、インタプリタを巻き戻すからだ。

## ?error とその親戚

`number`で数値変換できなければ`?error`を呼び出す。いままではダミーを入れていたが、今回、まじめに実装することにした。

Fig-FORTHでは`?error`がある。エラー系の外部インタフェースだろう。

```
?error ( flag num --- )
```

エラー発生でプログラム実行を停止して、外部インタプリタ・内部インタプリタを初期化・まっさらにして実行開始する。

具体的には、`flag`が`true`の時、エラーメッセージを表示して巻き戻す。

エラー発生時、`warning`が負または0であれば`abort`する。通常は`trap`。正の場合、エラー原因のワードを表示したのち、numに対応するメッセージを表示する。巻き戻しは、データスタックを初期化した後`QUIT`ループを巻き戻す。

本実装では、

* `?error`: ベクタ`'error`を実行する。base.f最初に定義している。
* `'error`: エラーワードを保持するベクタ。
* `(?error)`: 最後にベクタに代入されるワード。  
  ( flag n --- ): flag がtrueなら`(error)`を呼び出す。
* `(error)`: エラー処理ルーチン本体。`warning`チェック、エラー番号に応じたメッセージ処理、`sp!`(スタック初期化)、`quit`呼び出しを行う。

## プロンプト表示

`quit`でプロンプトが適切に表示されない。Fig-FORTHの実装ではちょっと変な気がする。`accept`の前に、`state != 0 && 「getlineがキー入力待ち」`の時だけ表示するように変更する。

Forthインタプリタのプロンプト表示を調べた。なにせ、動いているものを見たことがないもので。本を見ているだけではわからなかった。

* プロンプトは " OK" が表示される。この時、入力待ちはどこに出るのか？" OK"の行のすぐ後ろか? それとも、次の行の先頭か?
* プログラムの実行結果との関係は?実行完了後改行無しで" OK" か?、それとも改行後か?

YouTubeでForth処理系の動画を見た結果、

* 実行結果の後ろ、改行無しで " OK"が追加される。
* " OK"のあと改行が入り、ユーザ入力は次の行の先頭から開始。
  
であることが分かった。ファイル入力中とコンパイル中にはプロンプトは出さないので

* `outer`: ファイル入力中にtrue
* `state @`: コンパイル中に 1

を使って、両方ともゼロのときのみプロンプトを出力するようにした。

Forth版quitに導入していい感じに動いていることを確認した。C言語版にも導入した。

## ?stack ... スタックチェック

interpretにスタックチェック`?stack`を組み込んだ。インタプリタループで、?stackが呼び出される前にC言語版のほうで引っかかってアボートが入ってしまう。

`+`演算子を連続して実行する。スタックが1個の時点で?errorに引っかかってほしいが引っかからない。プリミティブm_addでも引っかからない。

プリミティブで引っかからないのは、tos(cx)でスタックポインタを動かさないから。tos(cx)の参照、代入でまずいはずだが、これはC言語マクロ定義で範囲チェックしていない。

さてどうするか？とりあえず現状進行とする。それよりも最後の大物、`:`, `;`が先だ。

## `:`, `;`

コロンとセミコロンをコロン定義でつくる。これで大物はすべてコロン定義ワードになるはず。

ということで、難なく進むはずが意外に苦戦している。セミコロンはベクタ`semicolon`で対応したが、コロンもそうすべきかもしれない。

結局、セミコロンのみプリミティブを2つ作り、';'の定義の際に';;'を使うようにした。createのあとで、hereがpfaを指していることに留意して、cfa書き換えの際に２個戻す。ワードcolonでなく、その２バイト先をcfaに入れること。

## TODO

この時点でのTODOをまとめておこう

* find定義の見直し。Fig-Forth定義と異なる。このまま進めるが、
* 複数辞書検索対応を入れる。
* 複数辞書の構成、これからクロス開発するので、ROM/RAMが先か。
* CURRENT: 定義追加対象の辞書
* CONTEXT: 検索対象の辞書
* クロス開発の際の辞書構成、base.fのコンパイル(FORTH辞書への追加)、
* クロス開発開始で、TARGET辞書へのTARGET PRIMARYのロード、base.fのTARGET辞書への追加、
* ROMはワンパックでバイナリイメージの生成まで。
* CONTEXT: FORTH辞書(ホスト環境、実行用ワード)
* CURRENT: コンパイル対象。TARGET辞書
* TARGET辞書を整える(./cpnrコマンド自体の挙動として)。
* DEFINITIONS: はとりあえず不要。
* EDITOR, ASSEMBLERは実装しない。
* FORGETを入れる。
* ?cspを入れるとインタプリタがおかしくなるので外してある。
* H_ADDRから`DP`への切り替え。完了
* `compile` をプリミティブでなくコロン定義に書き換える"Systems Guide Fig Forth"に記載がある。簡単に書ける。→先頭に定義を追加できた。ただし`?comp`チェックはなしで。

## プリミティブの削減

`create`, `word`, `compile`を削減した。おかげで、`variable`, `constant`の定義が後ろに回されて、多くのシステム変数が、アドレス定数のコロン定義になってしまった。

`space`を削減した。これは他に差しさわりなくできた。

`[compile]`を削減した。最初にシンプル版(エラーチェック無し)を定義してそれで `."`などを定義した。

これで残りプリミティブは55個。あと減らすべきは`dd`(ワード定義ディスアセンブル)ぐらい。

`getline`, `lnum`はやむを得ないだろう。

```
: WORDXT_ADDR   0x401c ;
: #field_addr   0x401e ;
: #base_addr    0x4020 ;
: outer_flag    0x4022 ;
```

## 定義語コンパイルの際に使用する内部インタプリタアドレス

* SEMI_ADDR: ワード';'のcfa, `does>`で使用している
* COLON_ADDR + 2: 機械語COLONのアドレス、`does>`, `:`で使用している。
* ワード`dolit`のアドレス。ワード`literal`、`dliteral`で使用。
* ワード`count`, `type`, `here`, `trap`のアドレス、ワード`."`, `abort"`で使用。
* ワード`semi`のアドレス。SEMI_ADDR @ と同じ。ワード`;`で使用。

`'`の検索先はホスト環境ビルド時とターゲット環境ビルド時に注意して分けないといけない。あとに`,`を置いてターゲットにコンパイルするためにxtを検索するので、ターゲット辞書をサーチすべきなのだろうが。

セルフ開発用は、CONTEXT, CURRENT とも clang.dict のロード、base.fのコンパイル後に clang.bin を生成する。次に z80.dictをロード、CURRENTをz80.dictとしてbase.fをコンパイルしてz80.binを生成する。まずこれでやってみよう。

z80.dictをプリプロセスして z80.s を生成してアセンブラに食わせてバイナリを生成する。./cpnr内でz80.Xをロードしてbase.fをクロスコンパイルするイメージ。

## `'`が早くに欲しい(→やっぱり現状でいいか)

現状は739行目。前倒しできないか。

`word`, `-find`, `compile dolit`(ラベルDOLITを定数化すればよい), `,`(これは60行目で定義できている)が必要。

`word`: 現在 579行目、前倒しできるか？

うーん、あまり前倒しの効果はなさそう。

> のちに(5/29)、C言語プリミティブとして実装した。ユーザ変数を最初に初期化するためである。

## エンディアン識別ワード

辞書はビッグ/リトルの区別が必要、ターゲットビルドの際に`!`, `@`でバイトスワップするかどうかを判断する。

ターゲット辞書へのワード読み書きの際にバイトスワップするかしないかを示すフラグを用意する。

ターゲット側にコンパイルするときは、`!`, `@`の定義も変える必要がある。base.fの精査が必要だ。

ターゲットへの書き込みは`,`でバイト順を合わせる(スワップするかしないか)ターゲット辞書の読み出し(find系)の定義は要注意。明示的にターゲット読み出しを記載する。

> X形式ファイルがエンディアン依存ない形式なので、辞書に書き込む際にエンディアンを扱うのではなく、辞書ダンプ(ddコマンドを改造して作る)で、エンディアン非依存形式にすることを考えている。が、dict.s部分はしんどいかな。もう少し考える。

## クロス開発のイメージ

1. ターゲット用プリミティブ辞書の作成: `(clang/z80/mc68000...).dict`
   + プリミティブは機械語ルーチン+アドレス(非ワード)とワード形式から成る。
   + *.dictにアセンブリ命令を書けるようにする。
2. 辞書イメージの設計
   + 開始アドレス、機械語アドレステーブル(colon)、エンディアン識別ワード

## 機械語ページ

```
                org     0x1000
1000            jmp     cold (coldにジャンプする) 
1004            .db     'M','Z' (0x4d5a or 0x5a4d)
1006 colonv:    .dw     colon
1008 nextv:     .dw     next
100A runv:      .dw     run
100C sdoesv:    .dw     startdoes
100E semiv:     .dw     semi
1010 execv:     .dw     execute
1012 trapv:     .dw     trap
```

内部インタプリタ

```
1014 colon:     m_colon1        ; PUSH IP -> RS
                                ; WA -> IP
1016            m_jmp next
1018 semi:      .dw  .+2        ; code field address
101A            m_semi1         ; POP RS -> IP
101C next:      m_next1         ; @IP -> WA
                                ; IP = IP + 2
101E run:       m_run           ; @WA -> CA
                                ; WA = WA + 2
                                ; CA -> PC
     entry_000:
     e_execute:
1020            .head "execute"
1028            .dw   0
     do_execute:
102A            .dw  .+2
102C execute:   m_exec1         ; POP SP -> WA
102E            m_jmp  run
```

プリミティブワード

```
    entry_001:
    e_dolit:
1030            .head  "dolit"
                .dw    entry_000
    do_dolit:
                .dw    .+2
                m_dolit
                m_jmp  next
```

`opcode dolit`で、

```
entry_001:
e_dolit:
    .head   "dolit"
    .dw     entry_000
do_dolit:
    .dw     dw  .+2
```

まで生成し、アセンブラがバイナリを生成する。残りは手で打ち込む。よって、
makedict.sh の入力としては、(dict.dict)

```
opcode dolit
    m_dolit
    jmp  next
```

だけ書けばよい。ターゲットCPUの場合、例えば、

```
opcode add
    pop  hl
    pop  de
    add  hl,de
    push hl
    jmp  next
```

と書く。

## v0.8 タグ付け

現時点で動作するバージョンをタグ付けしておく。

## 新仮想マシン、ジャンプ命令の導入

ジャンプ命令を1ワード、かつ最大限ディスプレースメントを確保するために、b15==1のワードすべてがディスプレースメント15ビットの相対ジャンプ命令とすることにした。

そのため、現在0xc000-c03fに収まっている値を0x7000からに引っ越ししてもらった。

この引っ越しで、makeopcode.sh を改良した。今は、`machine.h`の

    #define OPCODE_BASE 0x7000

を書き換えるだけで`opcode.inc`(アセンブラスクリプトas.shでインクルードして使用する)の変数`opcode_base`に反映されるようになった。

命令の値がおかしかったのは、`dict.list`を見て発見できた。ターゲットCPUに移植する際も類似のトラブルに遭遇しそうなので、事前に対策をメモできてよかった。

これでcpnrが起動し、C言語テキストインタプリタ(do_mainloop)でワード引き・実行ができるようになった。今は`base.f`のabort(878行目)定義中でundefined instructionが出て停止する状態。

`does>`の中に命令m_startdoesの値を直書き(0xc005)していたところがあった。これを0x7005に書き直したところ無事起動。
プロンプトまで出た。

## 今後のネタ

#### 最小exe

`cpnr`を内部インタプリタのみとする。バイナリを最小にするため。組み込み系ではC言語部を最小にしたい。
do_find, mainloopなどすべて消してしまう。

正確には別ファイルとして、それなしでもビルドできるようにする。

* 辞書バイナリをロードして先頭にジャンプインする。
* 先頭にはジャンプテーブル、`cold`エントリの`execute`ルーチンに飛ぶ
  + IP, SP, RSを初期化してIPに`m_halt`ポインタを入れて、
  + `cold`のxtにジャンプする。
  + C言語版はdo_machineループを開始

現在のC言語版テキストインタプリタは、C言語からの仮想機械実行開始は、レジスタ初期化の後、`abort`実行の時点で仮想機械がスタートしている。それを念頭に上記を行った。

#### 辞書書き出し

* 先頭からlastまで。最初はプリミティブとする。名前は`savedic`
* インタプリタ時に文字列を置く方法を決めてから、`savedic \ ( addr1 addr2 c-str --- )`にする。

> dictdumpになった。`dictdump @ here last dictdump`でファイル`forth.bin`を生成する。決め打ちもどうかと思うが。

#### ユーザページ

* ユーザ変数、スタック2個、行入力バッファ、出力`pad`を一塊にする。
* ユーザ変数(max 128b)/SP/行入力バッファ(max 128b)/RS

> 結局、辞書先頭にそのままユーザページの初期データを置くことにした。Forthロード開始までは仮データだが、Forthロード`user.f`の中と、`base.f`ロードの過程でユーザページの設定が増え、dicdumpの前にライブのユーザ領域を(ターゲット)辞書先頭に書き戻している。

#### ターゲットバイナリビルト

* ターゲットのORGで辞書をビルドしてダンプする。
* ビルド元の処理系は`ORG 0x8000`で`prim.dict`をアセンブル(`prim.X`)。
* C言語インタプリタ版でロードして、`base.f`を実行しインタプリタを含む辞書をビルド
* ここで辞書をダンプして、最小版でも実行できることを確認しておく。
* ターゲット用処理系を`ORG 0x0000`でアセンブル`{target}.dict`→(`{target}.X`)
* ORG 0x8000版インタプリタをロードして、`{target}.X`をロード、このときTARGET辞書がセットされている。
* ORG 0x8000版のABORTの実行開始して、`base.f`を実行しインタプリタを含む辞書をビルド。これでターゲット用処理系ができている。
* ターゲット用処理系を含む辞書をダンプ、これをターゲット上でロード・実行すると、ターゲット上でForth処理系が動く。

## 再ロード

`CONTEXT`: 辞書サーチ開始点のポインタ、`CURRENT`: 定義追加点のポインタ。

0x8000版プライマリバイナリ(prim.X)のロード、`base.f`のコンパイル、`quit`の実行の後、

* ターゲット用プライマリバイナリ(`cpnr.X`)のロード、
* `CURRENT`, `CONTEXT` の切替、cpnr.X辞書のlast, entryを指す。

Forth版インタプリタとコンパイラワードの見直しの前に、再ロードプリミティブ

## 0x8000番地にコンパイル・ロード

`dict.dict`の .orgを0x8000に変えるだけでうまくコンパイルし、`abort`テキストインタプリタが起動できた。

## メモリマップ見直し

ユーザ変数、２個のスタック、行入力バッファをfig-Forth風に変更した。1枚、

* データスタック: 256バイト
* 行入力バッファとリターンスタック: 256バイト
* ユーザ変数領域: 適宜(現在48バイト程度)

を連続で確保するようにした。

## user.def 導入

ユーザ変数定義ファイル user.def を導入した。

```
    .org 0xf000
    .user DICTTOP
    .user LAST
    .user DP
    ...
```

ユーザ変数の先頭領域を .org で指定する。上記の連続ページの上位512バイト目、リターンスタック初期アドレスを指定する。

.user エントリ、すべて大文字+数字の単語には`_ADDR`を付ける。それ以外は `*.f`のみ定義される。`#field_addr`, `#base_addr`はForth版定義のみとなる。 

`user.def` ファイルからC言語ヘッダとForth言語定義を生成する。

```
$ sh makeuser.sh -h user.def
$ sh makeuser.sh -f user.def
```

で、user.f, user.h を生成する。

## 辞書バイナリダンプ

プリミティブ`dictdump`を新設した。

```
dictdump ( start end --- )
```

で、開始・終了アドレスを指定する。保存先ファイル名は`forth.bin`固定である。

辞書バイナリダンプはバイトオーダをうまく扱わねばならない。`*.X`形式はワード・バイトを区別しており、この形式の場合はCPUのバイトオーダにかかわりなく共通形式で書ける。

この形式でダンプするためには、辞書構造をパーズして、文字列とリテラルを識別してバイト形式とワード形式を区別して書き出す必要がある。メリットは大きいが今日のところはサボって、生イメージダンプで実装した。

## ロード見直し

dictdump語のbinイメージの再ロードと、従来の dict.X ロードを両立するために

* dict.X user.f base.f の３ファイルロードと
* forth.bin のダンプイメージ再ロード

とした。第１引数は辞書イメージのロード、`*.bin`形式か`*.X`形式とする。

辞書イメージは拡張子`*.X`か`*.bin`のいずれかで、名前でロード形式を判断する。

辞書イメージが`abort`定義を含まない場合は、C言語版インタプリタを起動する。また、第２引数以後の`*.f`ファイルを順次コンパイルしてゆく。最後のファイルの最後に`abort`と書いておけば、テキストインタプリタが起動してForth処理系らしく起動する。

辞書イメージが`abort`定義を含む場合は、そのxtをexecuteする。

現在、`bin`ファイルロードから`abort`起動の箇所のデバッグ中である。まだ動いていない。

## dictdumpデバッグ

デバッグの結果動作した。問題は、

* dumpの際に辞書ヘッダ(最初の3ワードのend, entry)を更新していなかった。dictdumpを3引数取るようにして、`dicttop @ here last` の3値を渡すようにした。
* dictdumpとddのエントリが重なっていた。もともと `opcode dd dictdump`としていたため、m_dictdump命令が2個できていた。`dd`と叩いてもdictdumpが実行されスタック掘りすぎでバイナリイメージをダンプしていた。
* 辞書バイナリロード後、`abort`をワードサーチしてそのxtをdo_executeした。これで起動はする。

## バイナリ起動

main関数でname2xt, do_push, do_executeでabort起動する。テキストインタプリタが動作している。

* スタック表示、`.`が全部一桁しか表示しない。ただし、`' abort dd` で辞書定義がダンプされているので、表示がおかしいだけで動作はしているようだ。
* どうやらダンプ時のユーザ変数を保存していないのが原因らしい。辞書しか保存していないので、`base.f`で辞書定義以外のワード実行結果は保存していない。variable, constantは辞書エントリ内に実態があるので良いのだが、ユーザ変数は辞書領域以外に値を保存している。dictdumpでは当然保存していないのでダメなのだろう。
* ユーザ変数の保存とリストアを行うことを考えねばならない。

## ユーザ変数の保存とリストア

`10 #field_addr !`と手で打ち込むことで、`.`やスタック表示が正しく表示できるようになった。やはりユーザ変数初期化だろう。

設計で悩んでいる。以下の選択肢3つがある。

1. ユーザ変数を定数初期化するForthコードを書いて起動時に実行する。バイナリサイズが大きくなりそう。
2. 辞書イメージにユーザ変数領域の複製を持っておき、起動時`m_cold`プリミティブを呼び出しその中でユーザ変数領域にそれをコピーする。
3. 辞書エントリとしてユーザ変数領域の複製を持っておき、起動時にその先頭アドレスを得て手でコピーする。辞書エントリ作成が面倒そう。機械語coldの中で辞書エントリ内部のユーザ変数初期化データアドレスを得るのが面倒。なので、Forth版coldの中でコピーするコードを書くことになる。

単純明快なのは(2)辞書イメージにユーザ変数領域の複製を持つこと。ただし、これでバイトオーダ依存になってしまう。これで行こう。

バイトオーダは、辞書イメージからXファイルを生成するときに考えるか。

* 辞書イメージ末尾にユーザ変数領域をコピーして持つ。
* 辞書イメージヘッダに`UP`,`USER_MAX`を追加する。4番目と5番目。
* 同時にユーザ変数としても`UP`,`USER_MAX`4番目5番目に設ける。
* 辞書イメージ開始点(コピー元)は`HERE_ADDR @`で取れる。コピー先は`UP_ADDR @`, バイト数は`USER_MAX_ADDR - UP_ADDR`でよい。
* `dictdump`中では、`UP_ADDR @`から`USER_MAX_ADDR - UP_ADDR`をイメージ末尾に書き足す。
* 辞書イメージ作成時、`dictdump`呼び出しはすべての定義を終えてから呼び出す。さもないと`dictdump`以後に定義したワードが漏れてしまう。

このやり方だと、ターゲット辞書を作るときに、`UP_ADDR`(辞書イメージの4ワード目)を書き換えるだけで任意の場所にユーザ変数を置けそう。

辞書先頭のユーザ変数定義(`base.f`の先頭)を`UP + offset`となるように書き換えておくだけで行けそう。

## 実装

とおもったのだが、結局は `init_user`を生成してその中で初期化した。

* `makeuser.sh -f`で`upost.f`を生成する。
* その中で、ユーザ変数を初期化する。
* かつ、`cold`を定義してから、`COLD_ADDR`に`cold`のxtを代入した。
* 最後に`cold`を呼び出す。
* C言語仮想機械で`COLD_ADDR`が非ゼロ(セット済)であれば`cold`をexecuteする。
* これで、`./cpnr dict.X user.f test.f upost.f`で起動するとForth版インタプリタが起動した。
* これで、`dicttop @ here last dictdump`で辞書を`forth.bin`にダンプし、
* `./cpnr forth.bin`でテキストインタプリタが起動した。
* `1`, `2`を叩くと、スタック表示が`[0001 0002 ] OK`となった。

これで辞書サイズ 8000 - A19A, 8.5kBまで増えた。まぁ、どう頑張っても 8kBに収まりそうにないのでいいか。

あと、これで Ctrl-Dするとtrapが起動してSegmentation Faultする。テキストインタプリタ版の`trap`が必要ですね。

## いやだめでしょう。

```
: cold init_addr abort ;
' cold COLD_ADDR !
cold
```

これで辞書ダンプしているので、辞書イメージの中に`forth.bin`の中に`COLD_ADDR`を初期化するコードは入っていないはず。たまたま動いているだけですね。

これ、`cold`と`COLD_ADDR`への代入が循環参照している。ベクタを使って解決？

## やっぱり array ですね。

array user_area でワード配列を切って、upからend_user - up をバイトコピーする。そのあとでdictdumpして、起動時にcoldでuser_areaからupにバイトコピーする。

arrayはダンプの際にワード列化して、エンディアンを吸収できるようにする。

## arrayで作った。

* `dumpuser`: user変数領域を保持するarray配列。
* `cold`内部で`restore_user`を呼び出し、テキストインタプリタを起動
* `cold`のxtを`COLD_ADDR`に保存したうえで、

```
: cold restore_user abort ;
' cold COLD_ADDR !
```

* `dumpuser`へのコピー

```
DICTTOP_ADDR dumpuser END_ADDR DICTTOP_ADDR - cmove
```

これで、`cold`のアドレス含めて最新のuser領域を辞書に保存できる。

## 辞書バイナリの生成

```
$ ./cpnr dict.X user.f base.f upost.f
dict.X: read_xfile
dicttop: 8000, last: 8306, h: 8318
name2xt: abort: no entry, error
name2xt: cold: no entry, error
start text interpreter
open: user.f
open: base.f

End: A12C, 212C(8492 ) bytes.
open: upost.f

narrowForth v0.9dev
dicttop @ here last dictdump
m_dictdump: begin: 8000, end: a19e, last: a18e
[] OK
```

```
$ ./cpnr dict.X user.f base.f upost.f
```

でインタプリタを起動する。この時点で辞書領域にuser領域のコピーまで済ませてある。

```
dicttop @ here last dictdump
```

で辞書ダンプ、`forth.bin`ファイルが生成される。

```
$ ./cpnr forth.bin
```

でForth処理系が起動できる。

## 残件

forth.bin を起動後、Ctrl-Dを入力するとtrapがかかるが、Segmentation Faultしてしまう。

## ユーザ領域再考

テキストインタプリタは完全にForth環境で動作しているが、ユーザ領域の初期化はいまだCコードで行っている。これもForth環境に移行したい。

正確には、ターゲットの初期化コード中で機械語初期化したい、もっというと、アセンブラの dw 並べて初期化コードゼロにしたい。辞書イメージ最初の48バイト(24エントリ)は、そのままユーザ領域の初期値でええじゃないか、という考え。

アセンブラでユーザ領域の値がどこまで書けるか、ですね。定数はもちろんOK、機械語ルーチンのアドレスがいくつか必要だが、ラベルをオペランドとしてdwすればよいですよね。なんとか行けるか。

仮想CPU(m_xxxコード)のアセンブラはオペランド数式が計算できないが大丈夫か、よくわからないのでとりあえずやってみて試そう。

`COLON_ADDR`を使っているのは`does>`だけだ。`does>`を使っているのは`constant`, `variable`だけだ。

`COLON_ADDR`はC言語版`:`(do_colondef関数)で使用している。もちろんコードフィールドに書き込むためだ。

`constant`は結局使っていない。`: name 0xXXXX ;`を代役に使っており、それで切り抜けられた。

`variable`は循環参照するワード定義の際に、一方をベクタとする際にいくつか用いている。`?error`, `abort`。

`dpl`, `#base`, `warning` はユーザ変数としてもよいかもしれない。ROM対応する際に、variableで確保する領域をRAMに取らねばならない。このイメージをどうするかは考えておかねばならない。

`SEMI_ADDR`を使っているのも`does>`だけだ。C言語版でも`;`(do_semidef関数)で、コンパイルするxtとして使用している。

`does>`を後ろに回して`'`(comma)より後で定義すると、ユーザ変数に`COLON_ADDR`, `SEMI_ADDR`はいらなくなる。

`LITERAL_ADDR`は使われていない。C言語版テキストインタプリタ内部、do_compile_numberで使われている。エントリliteralのxtが必要。このユーザ変数は廃止してもよさそう。'user.h'内部のLITERAL_ADDRは、アセンブラ定義から直接アドレスを取り、STAR(LITERAL_ADDR)をLITERAL_ADDRとすればよいだろう。

`ABORT_ADDR`は、結局`base.f`で使用せず、C言語版でも値を入れているが使っていない。これも廃止でよいだろう。

`COLD_ADDR`は必要。最終的にはForthテキストインタプリタのエントリポイントとして使う。ダンプ直前にユーザ変数に格納しておいて、forth.bin起動時にそれを取り出しexecuteする。

`HALT_ADDR`も必要。m_haltを置いたメモリのアドレスをdo_execute内部でIPレジスタに格納して行先のxtにジャンプする。呼び出し先の処理が終わると、結局IPが指すアドレスの値を取り、そこに機械語ジャンプするので、その受け皿としてhalt命令を使っている。仮想CPUの実行を停止し、C言語版テキストインタプリタに返る。

C言語版テキストインタプリタでexecuteはbase.fの1行目から必要なので、base.f内部での定義を待つことはできない。

現在ベクタ系ユーザ変数は以上なので、まとめると以下の通り。Forth世界のユーザ変数として保持しないようにする。これで、プリミティブ辞書の先頭に .dwで並べられるようになったはず。

 |ユーザ変数名|扱い・説明|
 |--|--|
 |HALT_ADDR|C言語インタプリタで必要、name2xtで辞書検索し初期化|
 |COLON_ADDR|Forth版`does>`は見直す。'(comma)定義後ろに回す。<br>C言語インタプリタで必要。name2xtで辞書検索し初期化|
 |SEMI_ADDR|Forth版`does>`は見直す。'(comma)定義後ろに回す。<br>C言語インタプリタで必要。name2xtで辞書検索し初期化|
 |LITERAL_ADDR|Forth版では不要。<br>C言語インタプリタで必要。name2xtで辞書検索し初期化|
 |COLD_ADDR|C言語インタプリタで必要。 name2xtで辞書検索し初期化。この値がゼロのときはC言語インタプリタを起動する。
 |ABORT_ADDR|現在は未使用。エントリ廃止する。|

`'`(comma)もC言語プリミティブにしてもよい。これを使用して生成したワード中には`'`(comma)のxtは含まれないからだ。正確には、「xtを含まないようにできるはず」だからだ。

## 辞書ダンプ完成

ユーザ領域初期化も含めて辞書ダンプの仕組みを仕上げた。

### 辞書ダンプ

`base.f`を持つ辞書を作成してダンプする(file: `forth.bin`)には以下のように行う。

```
$ ./cpnr dict.X user.f base.f dictdump.f
```

* user.f: ユーザ変数の定義、base.fで頻繁に参照されるので最初にロードする。
* base.f: Forthテキストインタプリタ本体。word, find, number, 数値出力, does>, :, ;, '、テキストインタプリタ実行に必要なワードすべてが最低限のプリミティブだけを使用してコロン定義で存在する。
* dictdump.f: init_user, coldを定義してから、COLD_ADDR に `' cold`(coldベクタ)を保存してから、実行中のユーザ領域を辞書先頭にコピーして、最後に辞書領域をすべてバイナリのまま`forth.bin`に書き込む。

バイナリ辞書は以下のように起動する。

```
$ ./cpnr forth.bin
```

cpnrは、COLD_ADDRが非ゼロであれば、それがスタートアップワードのxtとみなしてC言語版executeを実行する。coldの最初でスタックを初期化しておけば何も問題ない。現在はそうなっていないが。

coldでは、まず、辞書先頭のユーザ変数領域をメモリ上にコピー(init_user)して、abortを呼び出す。

init_user, coldは、dictdump.fで定義されている。

### ユーザ変数領域の初期化

辞書先頭にユーザ変数の初期値領域がある。辞書先頭から`(END_ADDR - DICTTOP_ADDR)`バイトがそれである。

現在は、C言語関数init_dictでユーザ変数領域上に値を並べている。一方で、辞書領域先頭に雛形を作るところまでできているので、辞書ロード、インタプリタ実行開始の前に(init_dict呼び出しを廃して)それをユーザ変数領域にコピーするようにすればよい。

領域コピーをbase.f以前にForth手続きで書くのはしんどい。C言語版インタプリタではinit_dict中で(値を並べるのではなく)、辞書先頭をユーザ変数領域にコピーするようにすることになるだろう。init_dict関数を変更してバイトコピーするだけにしてしまう。

base.fを読み込みdicdump.fでダンプすると、dictdump.f内部で定義されるcoldワードの最初で「辞書先頭からユーザ変数領域にコピー」を行なっている。init_userがそれを行なっている。base.f内部にcmoveワードが定義されているので楽勝なのである。

### ユーザ変数定義ファイルと、３ファイルの生成

ユーザ変数定義ファイルでは、ユーザ変数の名前と初期値を記述している。

ファイル名`user.def`がそれで、

```
    .org 0x8000         // 
    .user_org 0xf000
dict:
    .user DICTTOP dict
    .global here_addr
here_addr:
    .user DICTEND entry_end
    .global last_addr
last_addr:
    .user DICTENTRY entry_head
    .user DP here_addr
    .user LAST entry_head
    .user UP
    .user USIZE 
    .user S0        // DICTTOP_ADDR 256 +
    .user R0        // DICTTOP_ADDR 512 +
    .user TIB       // DICTTOP_ADDR 256 +
    .user STATE     0
    .user DEBUG     0
    .user BASE      10
    .user HALT      // ' halt
    .user COLON     // ' colon 
    .user SEMI      // ' semi
    .user LITERAL   // ' dolit
    .user PAD       0
    .user IN        0
    ...
    .user END

```

`.org`は辞書領域の先頭を、`.user_org`はユーザ領域先頭を指定する。ROM/RAM構成で動作させることを考えているので、ユーザ領域は辞書と連続でない、別の場所を指定できるようにしてある。


この定義からアセンブリ言語`user.s`、Forthワード定義`user.f`、C言語ヘッダ`user.h`を生成する。生成プログラムは`makeuser.sh`である。第一引数でどの形式を生成するかのオプションで指定する。

アセンブリ言語は、`.org`をはじめ辞書ヘッダの初期値を`.dw`を使って生成する。

```
    .org 0x8000         
dict:
    .dw   dict        ; DICTTOP_ADDR
    .global here_addr
here_addr:
    .dw   entry_end        ; DICTEND_ADDR
    .global last_addr
last_addr:
    .dw   entry_head        ; DICTENTRY_ADDR
    .dw   here_addr        ; DP_ADDR
    .dw   entry_head        ; LAST_ADDR
    .dw   0    ; UP_ADDR
    .dw   0    ; USIZE_ADDR
    ...
```

先頭３ワードが「辞書先頭アドレス」「辞書末尾アドレス」「最新ワード先頭」を表す。アセンブラのラベルでそれらのアドレスを表すようにしているので、`.dw`のオペランドにはそれらラベルを書くだけでよい。

定数は普通に整数値を書く。仮想CPU用アセンブラが雑くてオペランドを式を評価することができないので、ラベルで書くか定数で書くかのいずれかしかできない。例えば、ユーザ領域のサイズ(バイト数)USIZE_ADDRに`END_ADDR - dict`と書けないのである。よって、user.f内部でForth定義として計算させることになる。

アセンブラの`.dw`擬似命令で辞書先頭にエリアをきちんと確保することが本プログラムのキモとなる。

Forthワード定義は、ユーザ変数アドレスシンボルを定義し、いくつかの値を計算して設定する。

```
: DICTTOP_ADDR     0xf000 ;
: DICTEND_ADDR     0xf002 ;
: DICTENTRY_ADDR   0xf004 ;
: DP_ADDR          0xf006 ;
: LAST_ADDR        0xf008 ;
: UP_ADDR          0xf00a ;
...
```

本ファイル末尾で式で計算して代入している。これは、定義ファイルの`//`以後の式を使っている。

```
 DICTTOP_ADDR 256 +   S0_ADDR          !
 DICTTOP_ADDR 512 +   R0_ADDR          !
 DICTTOP_ADDR 256 +   TIB_ADDR         !
 ' halt     HALT_ADDR        !
 ' colon    COLON_ADDR       !
 ' semi     SEMI_ADDR        !
 ' dolit    LITERAL_ADDR     !

```

計算結果はRAM上のユーザ変数領域に格納されている。辞書ダンプの時にはこの値を辞書先頭に反映させるためのコピーする。


辞書エントリのアドレスを計算できるように、`'`(quote)をC言語プリミティブとして作成・追加した。quoteは`base.f`内で再定義され置き換えられる。この辺りの置き換え処理はまだ怪しい。見直し必要。

C言語ヘッダファイルは以下の通り。C言語内でユーザ変数にアクセス(read/write)する際に使用できるようにマクロを定義している。

```
#define DICTTOP_ADDR     0xf000
#define DICTEND_ADDR     0xf002
#define DICTENTRY_ADDR   0xf004
#define DP_ADDR          0xf006
```

## 内部インタプリタの改造

現在の実装では、COLON, SEMIは辞書エントリとして作っている。ターゲットCPUのアセンブリ言語で書くことを考えると、辞書エントリまるごとは不便である。仮想CPU命令がCOLON,SEMI,NEXTそれぞれを1エントリとして分けているが、アセンブリ言語で書くと、


    Location   Mnemonic Instruction  Comment  

    0140       COLON   PSH I -> RS  
    0142               WA -> I  
    0144               JMP         ; Jump to NEXT  
    0146               0104          

    0100       SEMI    0102        ; Code address of SEMI  
    0102               POP RS -> I  
    0104       NEXT    @I -> WA  
    0106               I = I + 2  
    0108       RUN     @WA -> CA  
    01OA               WA = WA + 2  
    010C               CA -> PC  

    0050               7E          ; Dictionary  
    0052               XE          ; header  
    0054               LA          ; for EXECUTE  
    0056       EXECUTE 0058        ; Code address of  EXECUTE  
    0058               POP SP -> WA
    005A               JMP         ; Jump to RUN
    005C               0108  

なので、

    COLON:    m_colon1
              m_jmp     NEXT
    SEMI:     .+2
              m_semi1
    NEXT:     m_next1
    RUN:      m_run

と書きたい。

従来の m_colon は、

    m_colon1
    m_next1
    m_run

m_nextは、

    m_next1
    m_run

m_semiは、

    m_semi1
    m_next1
    m_run

に相当する。C言語版`machine_code`関数では、goto命令を用いて switch文内部で飛び回っていたが、すべて単一の命令に分割するイメージである。

ユーザ変数の、COLON_ADDR, SEMI_ADDR は、Forthプログラム内で辞書引き('(comma)ワード)でえるのではなく、アセンブラ言語中のシンボルを `.dw` の後ろに書く。

m_executeは、従来通り`opcode execute`でエントリを作る。

## init_memのユーザ領域初期化を無しとすると、

辞書先頭の初期値を0xf000にコピーして試行した。動かなかった。
`dolit`のベクタ初期化だけは必要だった。これは辞書エントリとしても必要なので、アセンブラのラベルで初期化するわけにはいかない、こともないか。

辞書アセンブリコード生成時に各エントリのxtにラベルがつけてあるので、`user.def`中でそれを参照すればよい。

```
    .user LITERAL   do_dolit
```

これでC言語版インタプリタでユーザ変数アドレスの定義が通った。

## semiが通らない。

user.fは通った。base.fはsemi not foundが出る。ワードsemiの定義がなくなったため。とりあえず、`SEMI_ADDR @ ,`で代用しておく。

## :, ;の定義でもcolon, semiの辞書エントリを検索していた

ので、ここも`SEMI_ADDR @`, `COLON_ADDR @`で置き換えた。

## これで forth.binイメージダンプと、実行ができるようになった。

```
$ ./cpnr dict.X user.f base.f dictdump.f
```

で、forth.bin辞書イメージのダンプができる。

```
kuma@Norihiros-MacBook-Air src % ./cpnr dict.X user.f base.f dictdump.f
dict.X: read_xfile
dicttop: 8000, last: 831c, h: 832e
init_mem: user copy: dest = f000, src = 8000, size = 50
name2xt: cold: no entry
start text interpreter
open: user.f
open: base.f
here comes 

End: A160, 2160(8544 ) bytes.
open: dictdump.f
m_dictdump: begin: 8000, end: a190, last: a180
eof
```

辞書サイズ8.4kBぐらいでしょうか。仮想CPUのコードは効率が良すぎてこれですので、ターゲット用の機械語コードを入れると、9kB超えそうです。

## ターゲット版辞書ビルド

C言語版テキストインタプリタをホスト処理系としてターゲット版辞書をビルドする。現時点の考えは、

* ホスト処理系はtarget-dict.X user.f base.f dictdump.f をロードし、dictdump.f内部で出来上がった辞書をダンプする。
* このtarget-dict.Xはターゲット版機械語で構成されたものである。よって、ホスト処理系実行のためのdict.Xが別途必要になる。
* ホスト処理系実行には user.f, base.f のロードまでは不要と思われる(後述のとおり、コロン定義中のimmediate実行時は別であるが)。dict.Xの内部インタプリタとプリミティブワードのみでテキストインタプリタが動作する。テキストインタプリタ動作に必要なプリミティブがすべてC言語関数で準備されているため。
* 内部インタプリタ実行はdict.X内のワード定義のみ。ユーザ変数はコンパイル時の書き込みと内部インタプリタ実行時の参照・書き込みが別領域とする必要があり、その切り替えが問題となる。
* `create`, `,`はターゲットへの書き込みと決め打ちしてよい。`allot`もターゲットの辞書ポインタを更新する。`!`, `c!`は状況次第、一度base.fを調べる必要があるだろう。
* [TODO] C言語版インタプリタで辞書書き込みの用法確認、`STAR(addr) =`, `mem[addr] =`箇所のチェック。
* ターゲット版辞書ビルドの処理実行(user.f, base.fの「実行」)は、dict.XとC言語版テキストインタプリタで行う。コンパイル処理はすべてターゲット版辞書に追加してゆく。ワードサーチもターゲット版辞書をサーチする。`DP_ADDR`(コンパイル先の位置), `LAST_ADDR`(サーチ開始位置)はターゲット版辞書を指す場合、C言語版テキストインタプリタの実行の問題はないはずだが、本当にないかどうかは確認必要。
* `PAD`位置が`here`の上としているが、問題ない。ターゲット辞書の上側でも問題ないと思う。ターゲット辞書をコンパイルする先はRAMであり、その上側に数値出力用バッファをとっても問題ないはずだ。
* [TODO] ほかにDP_ADDR, LAST_ADDRを使っている場所の確認が必要。
* [TODO] コロン定義中の immediate 処理はホスト側ワード実行となる。どれだけのワードを使っているかのチェックが必要。結局、ホスト側もuser.f, base.fで構築した辞書が必要かもしれない。テキストインタプリタでインタプリタモードのexecuteはホスト側ワード、immediateワードがヒットすればホスト側辞書でサーチしなおしてそちらを実行する、という感じか。
* C言語版テキストインタプリタ(do_mainloop)内部にimmediateワード処理を入れる。base.fのinterpretには入れない(ややこしそう)。

結局、

1. C言語版インタプリタで辞書書き込みの用法確認、`STAR(addr) =`, `mem[addr] =`箇所のチェック。
2. C言語版インタプリタでほかに`DP_ADDR`, `LAST_ADDR`を使っている場所の確認が必要。
3. C言語版インタプリタ、`do_mainloop`を改造する。インタプリタモードで、ワードのexecute時と、do_findでimmediateワードがヒットした時には、ホスト側辞書でサーチしなおしてそちらを実行するようにする。
4. ユーザ変数の切り替え。`COLON`, `SEMI`, `LITERAL`はターゲット版ユーザ変数と、ホスト版ユーザ変数とで別になる。`:`や`;`で参照するときはターゲット版の値を参照し辞書に書き込む。`COLD`もターゲット版のxtを使う。ターゲット版辞書コンパイル時には、ホスト辞書に`COLON`, `SEMI`, `LITERAL`の値は焼き込み済のはずなので、たぶんこの4つはターゲット版の値に書き換えても大丈夫なはず。
5. ユーザ変数、DICTTOP, DP, LAST は即値ワード実行以外はターゲット側の値を使用して問題ないはず。

## ユーザ変数の切り替え

 |名前|ビルド時|最終ダンプ前|
 |---|---|---|
 |DICTTOP|都度用法確認。インタプリタはホスト側を使用、コンパイルで書き込む際にはターゲット側アドレスを使用|ターゲット値を書き込む|
 |DICTEND|都度用法確認。インタプリタはホスト側を使用、コンパイルで書き込む際にはターゲット側アドレスを使用|ターゲット値を書き込む|
 |DICTENTRY|都度用法確認。インタプリタはホスト側を使用、コンパイルで書き込む際にはターゲット側アドレスを使用|ターゲット値を書き込む|
 |DP|ターゲット側を使用(インタプリタは使用しないはず)|DICTENDの値をコピー|
 |LAST|ターゲット側を使用(インタプリタは使用しないはず)|DICTENTRYの値をコピー|
 |UP|都度用法確認。インタプリタはホスト側を使用、コンパイルで書き込む際にはターゲット側アドレスを使用|ターゲット側を使用|
 |USIZE|(ホスト・ターゲットで同じ値を用いるはず)|
 |S0|コンパイル時はターゲット側を使用、インタプリタはホスト側を使用|ターゲット値を書き込む
 |R0|コンパイル時はターゲット側を使用、インタプリタはホスト側を使用|ターゲット値を書き込む
 |TIB|(今は使用していない)|
 |STATE|都度用法確認。インタプリタはホスト側を使用、コンパイルで書き込む際にはターゲット側アドレスを使用|0を書き込む|
 |DEBUG|インタプリタはホスト側を使用|0を書き込む|
 |BASE|インタプリタはホスト側を使用|10を書き込む|
 |HALT|インタプリタはホスト側を使用|ターゲット側のHALTアドレスを書き込む(CPU実行を止めデバッガに制御を戻す)|
 |COLON|ターゲット辞書の値を使用(インタプリタは使用しないはず)|ターゲット値を書き込む|
 |SEMI|ターゲット辞書の値を使用(インタプリタは使用しないはず)|ターゲット値を書き込む|
 |LITERAL|ターゲット辞書の値を使用(インタプリタは使用しないはず)|ターゲット値を書き込む|
 |PAD|ターゲット辞書領域で構わない|ターゲット値を書き込む|
 |IN|0でよい。|0を書き込む|
 |STRICT|0でよい|0を書き込む|
 |CSP|0でよい|0を書き込む|
 |COLD|(多分使っていない)|ターゲット辞書の値を書き込む
 |#field_addr|ホスト側の値を使用する。|ターゲット値を書き込む|
 |#base_addr|ホスト側の値を使用する。|ターゲット値を書き込む|
 |outer_flag|ホスト側の値を使用する。|1を書き込む。|
 |END|(変数として使用しない)|(値を書き込まない)|

## dd (dump_entry)が仮想マシン語ワードに対応していない。

まぁ、当たり前なんですが。

## プライマリと二重定義のエントリのリスト

二重定義リストは、

```
9A84 #base
95D0 '
9756 .(
A06C :
A05A ;
A012 [compile]
96C0 count
9088 space
```

だった。

#base は変数とユーザ変数(`#base_addr`)で2重に定義されていた。変数は不要なので消す。

`.(` は9718と95EAで定義されている。両方とも完全に同一のコロン定義なので、後ろ側を消した。

count, space は同一定義が2箇所にある。循環参照の気配も感じられないので、後ろ側を消す。

`[compile]`も9FB0, 9648の2か所で定義されている。これは明示的にエラーチェックの有無で別定義になっている。最初の位置で使用したかったが、エラーチェック用ルーチンが未定義の状態なので、仮の定義で先に進んだのだった。これは重複を許して現状で進める。

最終的には、重複エントリは、

```
9580 '
9FE2 :
9FD0 ;
9F88 [compile]
```

となった。`'`. `:`. `;`は`base.f`コンパイルに必要なので、当初プリミティブを使ってコンパイルを進め、最後にコロン定義版を作成して、機械語ルーチン開発対象から外す。

コメント開始コマンド`(`, `\` はいずれもプリミティブではない。コロン定義で初めて出現する。C言語版テキストインタプリタ内部で抹消されているので、プリミティブには現れない。

で、プリミティブも一覧してチェックした。

`run`, `startdoes` は primary.dictからコメントアウトしてもビルドできた。動作もしている様子だ。ただし、現在の`does>`の定義には、0x7005 が決め打ちで入っている。この部分はターゲットアセンブリ言語の際には書き直し必要。

`r2>`, `>r2` も定義しているが使っていない。消す。

最終的なプリミティブは以下の通り、50エントリある。

後述の3エントリを除く47エントリを、ターゲットCPUのアセンブリ言語で定義する必要がある。

```
82DE dictdump   82CC d_dolit    82C0 u*         82B4 d<
82A6 m*/        829A m+         828E d+         8280 sp!
8272 rp!        8264 sp@        8254 outer      8242 getline
8234 +rsp       8226 lnum       821A dd         820E ;;
8202 ;          81F6 :          81E8 emit       81DA /mod
81CE >          81C2 +          81B6 -          81AA *
819E /          8190 and        8184 or         8176 xor
8168 not        815C >r         8150 r>         8142 rsp
8134 dup        8126 over       8118 drop       810A swap
80FC rot        80F0 @          80E4 c@         80D8 !
80CC c!         80BA s_dolit    80A8 ?branch    8098 branch
8088 dolit      807C '          806E trap       805C execute
804E halt       8040 nop        
```

このうち、`:`, `;`, `'`は、`base.f`で再定義されて以後そちらが使われる。`base.f`のコンパイルにはこの3つのプリミティブが必要である。C言語版・ターゲットビルド用Forthインタプリタではこの3エントリは必要だが、ターゲット用アセンブリコードからこの3エントリを消してよい。

> 組み込み向けには `getline`もForth版を使用する。

`dd`がC言語プリミティブであることはあまりよろしくない、面倒だがForth版を作っておきたい。

`wwtest`, `2,`も`base.f`から消しておいた。前者はテスト用ワード、後者は倍精度整数パッケージに移動させる。

現状、8000 - A0AA までとなった。8400バイトぐらいかな。

これにgetlineとddを入れるとやっぱり9kB近くまで行きそうだ。

## チェックメモ

### DICTTOP, DICTEND, DICTENTRY

辞書読み込み時に読み込んだ辞書(dict.X)のヘッダ3ワードで初期化される。ターゲット生成時はターゲット辞書が配置されるアドレスとなる。これはこんなものか。

cpnr立ち上げ時に、RAM上のユーザ領域に読み込んだ辞書ヘッダ(ユーザ領域初期値)がコピーされる。これもまぁよい。

ターゲット生成時は、主役はターゲット辞書で、コンパイル中のimmediate処理だけをホスト辞書検索とよさそうに思える。ユーザ領域のDICTTOP, DICTEND, DICTENTRYはターゲット辞書を指すとする。

C言語版では、立ち上げ時とdictdump時のみ、この3つを参照する。これで進めてよさそうだ。

### DP

do_word: 文字列行先を取る。返し値もSTAR(DP_ADDR)を積んでいる。ここはターゲット辞書側であってほしい。

do_create: 文字列は(たまたまだが狙って)ターゲット辞書の狙った場所に置かれている。リンクフィールドにリンク先アドレスを置いて、DP_ADDRをコードフィールドまで進めている。ここもターゲット辞書側であるべき。

do_colondef: コードフィールドに STAR(COLON_ADDR)の値を入れている。ここもターゲット辞書側であるべき。

do_semidef: STAR(SEMI_ADDR)をコンパイルしてからSTATEをゼロにしている。ここもターゲット辞書側。

do_compile_token: STAR(DP_ADDR)にスタックトップを書き込んでいる。ここもターゲット辞書側。

STAR(STAR(DP_ADDR)) = で検索して用法を見た。出てくるところを`compile_it`でまとめた。この中でSTAR(DP_ADDR)にワードを置いてからSTAR(DP_ADDR)をインクリメントしている。

第3引数flagの0,1で、文字列出すか定数出すかも切り替えるようにした。これでコンパイル時のデバッグ出力がかなり見やすくなった。

do_abort: アボート時にワード名をワードエリアから取り出す。ワードエリアとして`STAR(DP_ADDR)`を使っている。これもターゲット辞書側でよい。

do_mainloop: do_numberに渡す文字列アドレス取得として用いている。これもターゲット辞書側でよい。

read_xfile: 読み込んだXファイルの先頭の値をユーザ変数領域にコピーしている。ターゲットコンパイル時には、最初のXファイル読み込みでターゲット辞書側を指すようになる。とりあえずこれでよしとする。

name2xt: STAR(DP_ADDR)に引数文字列"name"をコピーしてdo_findを呼び出している。厳密にはDP_ADDRでなくてもよいし、すでにおいておるワード文字列を破壊してしまうのは心配だが、いまさら別の場所にするのも心配だし、動いているからまぁいいか。

以上まとめて、引数Forthファイル読み込み開始時にDP_ADDRはターゲット辞書末尾を指す。でよさそうだ。

現行のままで進める。

### LAST

do_find: 最初に検索対象辞書としてSTAR(LAST_ADDR)を使っている。「ターゲット辞書、ただしimmediate/exec in compileではホスト辞書」となる。

do_create: ひとつ前のエントリへのリンクとしてリンクフィールドの埋め草を取るのに用いている。ここはターゲット辞書であるべき。また、辞書ヘッダ生成の最後にSTAR(LAST_ADDR)を更新している。この更新もターゲット辞書であるべき。

do_colondef, do_semidef自体では使用・参照していない。

entry_head, entry_tail: 引数addrから辞書エントリを得る。このときエントリリンクを手繰っている。基本はターゲット辞書でよいはずだが、呼び出し元がソース辞書を期待している場合は要注意。

あとでentry_headの読み出し元も調べる。

read_xfile: Xファイル読み込み後にユーザ変数LAST_ADDRを初期化している。DP_ADDRと同様、起動時はホスト辞書、ターゲットXファイル読み込み後はターゲット辞書エントリを指すようになる。とりあえずこれで進める。

### UP, USIZE

C言語版テキストインタプリタでは使用していない。なんでもよい。

### S0

行入力バッファとして用いている。ターゲット辞書コンパイル中も変更しなくてよい。

うーん、コンパイルされるコードでS0_ADDRがどう使われているかは確認しておく必要がある。ターゲットのアドレスをコンパイルしておかねばならないので。

ターゲットのユーザ変数初期化コード(ターゲット辞書先頭の初期化領域)の値を変えておくだけでよいはず。dictdumpの直前に辞書先頭の書き換えの際にそうするようにする。

### R0, TIB

C言語版テキストインタプリタでは使用していない。なんでもよい。

### STATE

C言語版テキストインタプリタで使用しまくっている。ターゲット辞書コンパイル中もこの用法を変える必要はないはず。このまま進める。

### DEBUG

インタプリタの挙動に影響は与えない。このまま進める。

### BASE

ターゲット辞書コンパイル中に10以外に変更する必要はない。このまま進める。

### HALT, COLON, SEMI, LITERAL

ターゲット辞書コンパイル開始時に、ターゲット辞書プライマリバイナリ側のxtを設定してからターゲット辞書コンパイルを開始すること。

#### HALT用法

do_executeでワード呼び出し時の「次のエントリ」としてm_haltの置き場所としてcx->ipに代入してxtを呼び出している。

#### COLON用法

do_colondef: コードフィールドにSTAR(COLON_ADDR)を書き込む。

#### SEMI用法

do_semidef: コードフィールドにSTAR(SEMI_ADDR)を書き込む。

#### LITERAL用法

do_compile_number: 定数コンパイル時にdolitを書き込む。

### PAD

C言語版インタプリタでは使用していない。上記の通りS0_ADDRを使ってしまっている。将来的には変更したい。

### IN

getch内部で使用している。do_acceptで初期化される。C言語テキストインタプリタ実行時は現在のままでよい。ターゲットにコンパイルされるときのアドレスに留意。

これも、dictdump前のターゲット辞書先頭のユーザ変数初期値を設定するところで行う、でよいだろう。

### STRICT

do_pop, do_poprのスタック領域チェックでチェックフラグとして用いている。ターゲット辞書では参照もされなくなるだろう。このままでよい。

### CSP

C言語版インタプリタでは使用していない。このままでよい。

### COLD

init_mem: 辞書検索してxtを格納している。この時点ではホスト辞書側のcoldを指している。

main: init_memが終了してからSTAR(COLD_ADDR)の値を見て、非ゼロであれば、do_executeする。

コンパイル時には特に参照していない。dictdump時にターゲット辞書のcoldを検索してターゲット辞書ユーザ変数初期値領域に代入しておく。

ターゲット側では使わなくてもよいだろう。

### #field_addr, #base_addr

C言語インタプリタで使用していない。コンパイル時にはターゲット側のユーザ変数を指すようにしておく必要がある。STATEもそうだが、コンパイル時にターゲットユーザ変数領域を指すようにしておかねばならない。base.f側で要注意。

base.f(Forthコンパイル側)のチェックも必要だが、とりあえずC言語インタプリタの挙動確認を続ける。

### outer_flag

これ、C言語内部とユーザ変数と両方で定義されていて、両者につながりがあるようにみえない(`STAR(outer_flag)`がCコード内部にない)

が、プリミティブ`outer`が定義されており、そこで、C言語outer_flagを返す。このプリミティブは`prompt`出すかどうかの判定で使用している。

ユーザ変数としては不要ではないか。

プリミティブ`outer`は、外部ソース入力デバイスをサポートする場合に定義すべきもので、素のターゲット辞書には不要。

user.defからユーザ変数outer_flag定義を外しておく。

ここまでで、ユーザ変数のC言語版テキストインタプリタでの扱いのチェックは終わった。

## base.fチェック(ユーザ変数)

### DICTTOP_ADDR

dicttopが定義されている。dicttopを調べる。

dicttop: dictdump.f 内のみで使用されている。ターゲット辞書の値であるべき。現状でよい。

### DICTEND, DICTENTRY

base.f, dictdump.fどちらでも使用されていない。
(C言語でのロード時に使用されている)

### DP_ADDR

`dp`でこの値が返る。

dp: here, allot, hで参照されている。ターゲットコンパイル時にはターゲット辞書を指す値を入れておきたい。

### LAST_ADDR

base.fでは2箇所のみ。createでリンクアドレスを設定するところのみ。

last: create, -find(検索開始位置として), コメントワード定義後の名前文字列入れ替え処理の中で使っているが、すべてターゲット辞書を指すべきである。現状のまま進めてよい。

### UP_ADDR, USIZE_ADDR

user.fでの定義のみ、参照されていない。現状のままでよい。

### S0_ADDR

base.fでは、ワードs0の定義で参照している。

s0: 行バッファ先頭のアドレスを返す。word, accept内部で多数使用されている。quitで行読み込み後のチェック。ターゲットの行バッファを指せばよいので、現状のままでよい。

### R0_ADDR, TIB_ADDR, 

base.fでは使用無し。

user.fでも定義とアドレスの設定のみで、参照して使われていない。

### STATE_ADDR

ワードstateでアドレスを返す。

state: base.fコロン定義中で多数参照している。これこそimmediate状態での挙動を見るべきか。

ターゲット辞書コンパイル中のimmediateワード実行、または`[ ... ]`実行中は結局C言語テキストインタプリタでdo_find, do_executeでワード処理される。`[`, `]`ともstate書き換える。早々にユーザ変数STATE_ADDR書き換えるので、ホスト環境のstateは書き換えられない。

ここ要検討ですね。このままではまずい。

`[`: 自身をコンパイルするとき、ターゲット環境のSTATE_ADDRを参照するコードを生成する。

他のワードで`[`を使用するとき、ホスト環境のSTATE_ADDRを書き換えてほしいが、ターゲット環境のSTATE_ADDRを書き換えてしまうのでよくない。

最初は

* ホスト環境のSTATE_ADDRを書き換える`[`を定義する
* base.fの以後のコロン定義中で`[`を書く。ホスト環境のSTATE_ADDRを0にするので、ホスト環境テキストインタプリタが実行モードに変わる、以後の処理はワードごとに実行される(ホスト環境での実行)。
* `]`もホスト環境のSTATE_ADDRを書き換える定義とする。コロン定義中の実行モードで`]`に出会うと、ホスト環境のSTATE_ADDRが1になり、以後のワードはコンパイルモードでコンパイルされる。

このとき、生成されたワードに`[`, `]`のxtは含まれない。どちらもコンパイルされず実行され消費されてしまうからである。

* 最後にターゲット環境のSTATE_ADDRを書き換える`[`, `]`を定義して、その状態の辞書をdictdumpする。

* `[`, `]`をコンパイルする処理が入っているコロン定義では注意が必要。ターゲット用辞書をコンパイルしているときは、ここではターゲットのSTATE_ADDRを書き換える版のxtをコンパイルせねばならないが、`[`, `]`を'quoteでサーチして得られるものはホストのSTATE_ADDRを書き換える版だから。

そういう箇所がないかどうか、base.fを探し、あれば個別対応する。ExplicitにTARGET_STATE_ADDRを定義してそこを書き換えるコードをコンパイルする。

quitの最初で`[compile] [`がある。この前にターゲット版`[`を定義しておけばよい。

`;`にも`[compile] [`がある。これもターゲット版`[`がコンパイルされるはず。

その後ろに`:`があり、`[ LITERAL_ADDR @ , COLON_ADDR @ , ]`がある。これの意図は、ターゲット版の`dolit`, `COLON`をコンパイルする、である。

`:`を最後(dictdumpの前のinit_user, coldよりも後ろ、dictdump呼び出し直前)に置き、そこで`TARGET_LITERAL_ADDR, TARGET_COLON_ADDR`の値をコンパイルするように書き換える。`[ ' dolit ,  TARGET_COLON_ADDR @ , ]`でいいかもしれない。

`:`の定義を見直した。`[`, `]`なしで普通に`COLON_ADDR @ ,`と書けばよい。これで動作した。このままターゲット版辞書にコンパイルして問題ないはず。

### comments

コメントの定義は、1文字名エントリを作り、直後に文字列にパッチを当てる。パッチコードで使う`last`はターゲット辞書を指すので、ターゲットビルド時もこのままでよい。

### base.fでの変数初期化

debug, state, strict, cspを初期化しているが、今や辞書先頭の初期値をコピーするようになったので不要。すべて消してセルフビルドできるかを確認する。

### base.fでユーザ変数初期化コードを消した

base.fで大域で初期化するコードをすべて消した。ビルドでき、forth.bin起動できた。

但し、stateの値が0になっていた。strictの辞書ヘッダ初期値は1だが、Forth版quit先頭で0なので、`./cpnr forth.bin`起動後はゼロになっている。これで納得。

## ターゲット辞書コンパイル

いよいよC言語版テキストインタプリタの改造に入る。

* ユーザ変数`CROSS_ADDR`: ホスト辞書の`LAST_ADDR @`を代入しておく。  
  `CROSS_ADDR @`でdo_findのサーチ元が得られる。
* インタプリタモード(state == 0) or コンパイルモードでも検索結果immediate wordに遭遇したときは、ホスト辞書を検索してexecuteする。

クロスコンパイル開始のワード

* target.Xをread_xfileする。このときターゲット辞書の3エントリをユーザ変数3つに代入する。
* DP_ADDR, LAST_ADDR はターゲット辞書のEND, ENTRYの値を代入する。
* COLON_ADDR, SEMI_ADDR, LITERAL_ADDRはターゲット辞書のエントリを検索して上書きする。

クロスコンパイル手順

1. target.Xをロードする。
2. ホスト環境のユーザ変数領域を書き換える前に、lastの値をスタックに保存しておく。
2. ターゲット辞書先頭のUP_ADDRを取り出し、ホスト環境のユーザ変数領域にコピーする。
3. DP_ADDR, LAST_ADDRをターゲット辞書の2番目3番目で初期化する(2で終わっていて不要かもしれない)。
4. CROSSにスタックに保存して置いた値を書き込む。CROSSはホスト辞書のサーチ元である。
4. tuser.fをロードする。C言語版テキストインタプリタがコンパイルしてゆく。
5. base.fをロードする。C言語版テキストインタプリタがコンパイルしてゆく。
6. dictdump.fをロードする。C言語版テキストインタプリタが実行し、辞書ダンプまで済ませてしまう。

## ターゲット用辞書(target.X)のロード

裸のテキストインタプリタだけではターゲット辞書の構築は難しい。ホスト環境にそこそこのワードが存在し実行できるようにしておく。

そのためには、user.f, base.fもロードしたうえで、C言語版テキストインタプリタを実行しながらターゲット用辞書バイナリ(target.X)をロードするようにしたい。

do_accept/getline改造は難しそうでためらっていたが、Forthのメモリ書き込みワード列を生成して実行させればよいことに気づいた。

アセンブラでtargetバイナリをアセンブルしたオブジェクトのリストファイルを取得し、そこからXファイルを作成する。

XファイルからForthコマンド列を生成する`X2f.sh`(awkスクリプト)を作成する。あとは./cpnrの呼び出し時の引数に追加すればメモリ上に展開できる。

次は

* DP_ADDR, LAST_ADDRの切り替えと
* CROSSユーザ変数の新設、
* C言語版テキストインタプリタのfind部分の変更

である。この3つでターゲット版辞書が作成できるはず。

ターゲットコンパイルは、ターゲット辞書ロードして、`: aho 1 + ;`がターゲット辞書のワードのみ参照してできるところまできた。

* cross8.bin の生成。テキストインタプリタはC言語版を使用するバイナリを作る。

```
$ ./cpnr dict.X user.f base.f 
dict.X: read_xfile
dicttop: 8000, last: 82de, h: 82f0
init_mem: user copy: dest = f000, src = 8000, size = 50
name2xt: cold: no entry
start text interpreter
open: user.f
open: base.f

End: A0A4, 20A4(8356 ) bytes.
dicttop dicttop @ END_ADDR dicttop - cmove
[] [] ok
dicttop @ here last dictdump
m_dictdump: begin: 8000, end: a0a4, last: a088
[] [] ok
```

で、バイナリを作る。forth.bin を cross8.bin と改名しておく。

```
dicttop dicttop @ END_ADDR dicttop - cmove
dicttop @ here last dictdump
```

だけでfファイル作ってもいいかもしれない。

* ターゲット辞書のロード

`.org 0x1000`, `.user_org 0xe000` で辞書バイナリをビルドする。
target.X から X2f.sh を使い、Forth版ターゲット辞書に変換する。

```
0x1000 0x1000 !
0x12ee 0x1002 !
0x12dc 0x1004 !
...
```

としておくと、`./cpnr cross8.bin target.f xx.f`で辞書バイナリがロードできる。

辞書をロードした後、

```
variable dA
DICTTOP_ADDR 0x41 .ps - dA !
\ set cross
LAST_ADDR @ CROSS_ADDR !
CROSS_ADDR dup h4. space @ h4. cr
\ copy addrs
DP_ADDR dup dA @ + 0x42 .ps @ swap !
LAST_ADDR dup dA @ + @ swap !
COLON_ADDR dup dA @ + @ swap !
SEMI_ADDR dup dA @ + @ swap !
LITERAL_ADDR dup dA @ + @ swap !
DICTTOP_ADDR 48 dump
```

で、ホスト版ユーザ変数 DP_ADDR, LAST_ADDR, COLON_ADDR, SEMI_ADDR, LITERAL_ADDRをターゲットを指すように書き換える。

```
$ ./cpnr cross8.bin target.f xx.f
cross8.bin: dicttop = 8000, dp = a0a4, last = a088
init_mem: user copy: dest = f000, src = 8000, size = 50
name2xt: cold: no entry
start text interpreter
open: target.f
open: xx.f
A[1000 F000 ]
F02A A0A4
B[F006 1006 ]
F000 8000 A0A4 A088 12EE 12DC 0000 0000 F100
F010 F200 F100 0000 0000 000A 8056 1032 1036
F020 1090 0000 0015 0001 0000 A0A4 0000 0010
F030 0010 0000 0000 0000 0000 0000 0000 0000
F040 0000 0000 0000 0000 0000 0000 0000 0000
F050 0000 0000 0000 0000 0000 0000 0000 0000
```

これで`: aho 1 + ;`がコンパイルできる。

```
: aho 1 + ;
[] [] ok
last dd
dump_entry: entry = 12EE, tail = 1300
12ee .head "aho"
12f4 12dc  [link]
12f6 1032  [code]
12f8 1090 (dolit)
12fa 0001 (1)
12fc 11c6 (+)
12fe 1036 (semi)
[] [] ok
```

スレッドコード内のエントリがすべて 1XXX になっている。良い感じだ。

## 行入力機能のForth化

そろそろ行入力を準備しよう。

* 今までのを置いておいて、テキスト版行入力`EXPECT`を作る。
* プリミティブ`KEY`が必要。キー入力の1文字入力。

まず、key/key_in: 1文字入力プリミティブを準備した。続いて行入力機能を作った。MSBが立っている文字は無視し、^H(`\008`) or DEL(\177)で1文字消去が効くようにした。

だいたい動いた。が、interpretへの組み込み方が決まらない。現状の`accept`は`m_getline`を呼び出しており、この中で外部ファイルの読み込みのあとキー入力読み込みに切り替える。

キー入力に特化している`EXPECT`をどう統合するかに悩みがある。方針がふわふわしている不安定な状態。

ターゲット上でテキストインタプリタが走り出す時点でキー入力に限られている、とも言いたくない。ROMや外部ストレージのソースコードを読み取ることもしたい。現状の枠組みだと、getline内部で外部ストレージ入力とキー入力編集付を入れ替えるべきか。

現在プリミティブである`getline`を、Forth版で同一インタフェースでつくる。ベクタが定義されていればそれを呼び出し外部入力から読み込む。外部入力が尽きるとキー入力版に切り替える。としよう。

`EXPECT`で書いたコードを`getline`定義に切り替える。
ユーザ変数 `outer` をベクタとして扱う。outerがヌルであればキー入力行入力処理を行う。

```
: getline \ ( n addr --- )
    \ 先頭から詰める。ヌル文字までのデータが有効、count不要
```

であるので、Linux端末ドライバ+fgets相当になる。

`getline`デバッグできたので、base.f の acceptの直前に入れた。

デバッグできたと思っていたが違った。かなり変わったがなんとか動くようになった。

## クロスコンパイル

なんとか base.f のコンパイルを通すところまできた。

DP_ADDR, LAST_ADDR に tdict.X のヘッダから DP_ADDR, LAST_ADDR をセットして CROSS_ADDR に旧 LAST_ADDRをセットすると、C言語版テキストインタプリタは tuser.f base.f をコンパイルできる。

`start_target.f`でユーザパラメータの書き換えを行っている。

```
0x1000
variable dA
dup DICTTOP_ADDR - dA !
: cross CROSS_ADDR @ ;
\ 4 debug
LAST_ADDR @ CROSS_ADDR ! 
DP_ADDR dup dA @ + @ swap !
LAST_ADDR dup dA @ + @ swap ! \ ( cross org )
10 #field_addr !
drop
```

最初にターゲット辞書先頭アドレス(0x1000)を置く。

`dA`はターゲットとホスト差分。ユーザ領域のコピーの際のアドレス差分として用いる。今の場合は、

ターゲット: 0x1000  
ホスト:     0xF000

なので、その差 0x2000 が dAに代入される。

* まず、ホスト CROSS_ADDR に、ホスト LAST_ADDR の値をコピーする
* そのあと、ホスト DP_ADDR, LAST_ADDR に、ターゲット初期値エリアの DP_ADDR, LAST_ADDR の値をコピーする。

これで、実行するワードはホスト辞書から検索され、コンパイルされるワードはターゲット辞書から検索されるようになる。そのようにC言語版テキストインタプリタを改造しておいた。

ただし、ターゲット辞書のヘッダ(ユーザ変数初期値)はセットできていない。

これで、ターゲット用ユーザ変数アドレス(tuser.f)と基本ワード定義(base.f: ホスト環境と全く同じもの)をロードすると、0x1000 - 0x31de にターゲット用辞書が展開される。

```
kuma@LizNoir:~/cpnr/src$ ./cpnr cross8.bin tdict.f start_cross.f tuser.f base.f
cross8.bin: dicttop = 8000, dp = a1de, last = a1c2
init_mem: user copy: dest = f000, src = 8000, size = 52
name2xt: cold: no entry
start text interpreter
open: tdict.f
open: start_cross.f
F[1000 ]
@[1000 1000 F000 ]
A[1000 2000 A1E6 ]
2000
1[1000 A1E8 F02A ]
2[1000 F006 F006 2000 ]
3[1000 F006 1006 ]
4[1000 F006 1310 ]
B[1000 1310 F006 ]
C[1000 12FE F008 ]
D[]

open: tuser.f
open: base.f

End: 31DE, B1DE(-20002 ) bytes.
last dd
dump_entry: entry = 31C2, tail = 31DE
31c2 .head ":"
31c6 31b0  [link]
31c8 8036  [code]
31ca 2390 (create)
31cc 1672 (last)
31ce 171c (cfa)
31d0 15fa (dp)
31d2 10e0 (!)
31d4 1450 (COLON_ADDR)
31d6 10f8 (@)
31d8 16a0 (,)
31da 16b2 (])
31dc 803a (semi)
[] [] ok
0xf000 32 dump
F000 8000 A1DE A1C2 31DE 31C2 0000 0000 F100
F010 F200 F100 0000 0000 000A 1058 8036 803A
F020 8094 0000 000F 0001 0000 A1E8 0000 0010
F030 0010 0000 0000 0000 0000 0000 0000 0000
[] [] ok
0x1000 32 dump
1000 1000 1310 12FE 1310 12FE 0000 0000 0000
1010 0000 0000 0000 0000 000A 0000 1036 103A
1020 1094 0000 0000 0001 0000 0000 0000 000A
1030 0000 0000 0000 7002 8004 103C 7006 7003
[] [] ok
```

DP_ADDR, LAST_ADDR, CROSS_ADDRの値を設定するだけでコンパイルは最後まで通る。ビルドされた辞書の定義が適切かどうかは確認が必要だが。

今はターゲット用プリミティブがホスト用プリミティブと全く同じ(仮想CPU用コード)なので、辞書最終アドレス - 先頭アドレスがまったく同じになっている(0x21de)。

ターゲットCPU(Z80とか68000とか)によりプリミティブの機械語バイナリが異なるので、実CPU相手のターゲット辞書を構築する際にはサイズも異なるはずだ。

0x1000 の領域(ターゲット辞書先頭の初期値エリア)の初期値を適切に設定すれば先に進める気がする。

## 辞書ちゃんとできているかのチェック

```
.org 0x1000
.user_org 0xe000
```

で定義した辞書ファイルでイメージを作ってみるか。それと比較してみよう

これで作った辞書(forth1.binと名付けた)を見ながら、これで辞書が作れるのならターゲット版辞書もこれでつくったらええんとちゃうん？と一瞬思ったが、それは無理なのです。Z80や68000をターゲットとしたとき、そのプリミティブをロードしても仮想CPUしか実行できないC言語版インタプリタではコンパイルが先に進まない。base.fの中では、前の方で定義したワードを後ろで実行しているので、そうなる。

逆に言えば、前の方で定義したワードを後ろで実行しない(コンパイルはしても)が徹底できればよいのか。実行しなければならないワードはすべてC言語版で書けばよいのか？

いや、後ろで実行しようとしたときに前で定義したワードを実行してしまうのでダメか。最終的にターゲット版機械語ワードの実行になってしまうのでそこでダメになると思う。

クロスコンパイル版の辞書のdiffを取ってみた。全然足りていない。
8038とかが紛れ込んでいる。これ、COLON, SEMI, LITERALの書き換えが必要やね

```
DP_ADDR dup dA @ + @ swap !
LAST_ADDR dup dA @ + @ swap ! \ ( cross org )
```

COLON, SEMI, LITERALまでは書き換えても大丈夫。

```
COLON_ADDR dup dA @ + @ swap 0x43 .ps ! \ ( cross org )
SEMI_ADDR dup dA @ + @ swap 0x43 .ps ! \ ( cross org )
LITERAL_ADDR dup dA @ + @ swap 0x43 .ps ! \ ( cross org )
```

S0書き換えた瞬間に .psがおかしくなる。0xf100から0xe100にした直後から多数のワードをダンプするようになった。

```
S0_ADDR dup dA @ + @ swap 0x43 .ps ! \ ( cross org )
```

## makefile: ターゲットビルド手順の導入(6/11)

ターゲットは際限なく増えるが、増えたターゲットをそれぞれどうビルドするか。正解はわからないが、とりあえず１つのターゲットをビルドする手順を導入した。

これ以上は Configureかなぁ。makefile生成システム導入だわな。

* マクロ TARGET でターゲット名を導入する。例えば、`emuz80` とか。
* 今回のサンプルは、仮想CPUバージョンで、名前は`t`１文字とした。芸がないが、仮想CPUの名前をすぐに思いつかなったのが敗着。
* 最終ターゲットとして、t.binを生成する。`./cpnr -o t.bin cross8.bin t_dict.f start_cross.f t_user.f base.f cold.f dictdump.f`ターゲット機械語で構成された辞書バイナリを生成する。
* `cross8.bin` は以前生成したもの。0x8000の辞書を使用する。今の makefile では `cross8.bin`の実装手順が入っていない。これも書くべき。
* `t_dict.f`は、最小辞書バイナリ `dict.X` を、Forth言語でメモリに書き込むように変換したもの。
* `start_cross.f`: ターゲット辞書のコンパイル準備、`CROSS_ADDR`にホスト辞書の`last`を保持し、`DP_ADDR`, `LAST_ADDR`は先ほどロードした`t_dict.f`ターゲット辞書の`dp`, `last`を指すように更新する。合わせて、辞書イメージ先頭のユーザ変数初期値で、アセンブラで初期化できなかった部分も更新しておく。`S0_ADDR`, `R0_ADDR`, `TIB_ADDR`と、ユーザ変数領域と隣接する領域のポインタの初期化。
* `t_user.f`: ユーザ変数アドレスの初期化。ターゲット用の`DICTTOP_ADDR`, ...をワード定義する。以後の参照ではここで定義したアドレスを使う。コンパイル時はそれでよいが、ホストで実行時にこれらの定義でホスト環境のユーザ変数にアクセスできなくなったことに注意。
* `base.f`: Forth処理系本体。テキストインタプリタ・行入力`getline`を含む。ホスト辞書と同じものをターゲット用にも無修正でビルドできるようにしたい。
* `cold.f`: Forth世界のコールドスタートルーチンをベクタ定義する。ワード`cold`を定義し、ユーザ変数`COLD_ADDR`(ターゲット辞書先頭の初期値エリア)に代入する。ターゲット環境では、`COLD_ADDR`のアドレスを掘り出して飛び込めばForthテキストインタプリタが立ち上がるはず。
* `dictdump.f`: ターゲット辞書のダンプ。ダンプ先ファイルは、`./cpnr -o t.bin`のように、`-o`オプションで指定する。無指定の場合は、"forth.bin"が書き込みファイル名となる。

ターゲットプログラム作成・ビルド手順は以下の通り。

* 準備: asXXXX 、ターゲットCPUのアセンブリ言語ソースをアセンブルできること
* dump.sh: asXXXXの生成バイナリを X 形式に変換する。

* makefileを編集して、マクロ変数TARGETを`emuz80`に書き換える
* t_user.defをコピーしてemuz80_user.defファイルを作成し,編集する。ここで辞書開始アドレスとユーザ変数領域アドレスを指定する。ROM/RAM版の場合は、RAM辞書の先頭アドレスも指定する。
* t_inner.sをコピーしてemuz80_inner.sファイルを作成し、編集する。 Z80用の内部インタプリタをアセンブリ言語で記述する。ラベルは保存しておく。アセンブルしてオブジェクトが生成できるようにしておく。共通アセンブラ`asXXXX`を使用して、ユーザ変数の初期値もアセンブリ言語でできるだけ書いておきたい。
* オブジェクトから*.Xファイルを生成するためのdump.shスクリプトを調整しておく。共通アセンブラ`asXXXX`を使用して、`dump.sh`を共通で使えるようにしたい。アセンブリ言語で生成できなかった初期値もdump.shで算出・設定するように変更したい。
* t_primitive.sをコピーしてemuz80_primitive.sファイルを作成し、編集する。プリミティブをアセンブリ言語で記述する。
* アセンブラをmakefileで指定しておくと、makeと叩いて、emuz80_dict.sが生成され、アセンブルされ、Xファイルが生成され、最終的にemuz80_dict.fが生成されるはず。
* make処理は続き、`./cpnr`コマンドでターゲット辞書のロード・base.fのコンパイルと辞書ダンプまで進み、`emuz80.bin`が生成される。
* さらに、ターゲット用アセンブリ言語で記述したローダ(リセット後開始アドレスに置いて`COLD_ADDR`ベクタにジャンプする機械語コード)も別に作成しておき、`emuz80.bin`と一緒にそれもROMに焼く必要がある。

## やりかけ 6/12

* `UP_ADDR`変数、`S0`, `R0`, `TIB`初期化でやりかけ。

* `makeuser.sh -f`のForthヘッダ生成の途中。

* `.user_org`の扱いがいい感じになりつつある。

## 乗除算プリミティブについて考えた(6/12)

* base.fビルド内で乗除算(`*`, `/`, `/mod`)は使わないでおきたい。使わずにbase.fをコンパイルできると、乗除算プリミティブのデバッグを`forth`名でできるようになり便利。
* 乗算`*`はすべて`cells`との掛け算、よって、figForthの`cells`定義に書き換えるとbase.fコンパイル時点で`*`の動作不要となる。
* 除算`/`２箇所とも`cells`の除算。これは右シフトで代用できる。右シフトを導入し除算を削除する。
* 除算`/mod`: これは数値出力ルーチンで使用されている。必須なので避けて通れない。16で割る簡易版(これならデバッグなしで動きそう)を使用するようにして立ち上げて、テキストインタプリタ動作後に本物コードを書いてデバッグするか。
* すると、機械語プリミティブは余裕を持ったサイズにしておいて、そこだけパッチ当てしてデバッグできるとよいな。エミュレータデバッグが先かな。

## bye実装(6/12)

C言語テキストインタプリタで辞書ロード、cold実行して抜けるとSegmentation Faultする件を解決した。また`bye`プリミティブを実装した。インタプリタから抜けるやつ。

## ユーザ領域再考(6/13)

S0, R0, TIBの初期化: C言語テキストインタプリタはマクロDSTACK_END, RSTACK_ENDで行っている。

machine.hで定義されており、user.defと完全に独立である。

ホストコンパイル時、user.defで定義する値で初期化する。
アセンブラの限界により S0, R0, TIB の値は初期化できないので、この3つは、辞書ビルド最後に辞書先頭領域に値を設定する。

DICTEND, DICTENTRYは、here, lastで得た値を辞書先頭領域に書き込む。これら処理は finalize.f で行う。

xx.defに.constディレクティブを入れたバージョンがある。今回特にadd/commitしておく。

## ユーザ領域再考(6/14)

全データをユーザ領域(0xf000-)に持たねばならないという縛りは存在しない。辞書3パラメータは辞書先頭にあるものを参照すればよい。

定数系のものは、辞書ダンプ前に値を確定させ辞書先頭領域に格納すれば、次の実行時には辞書先頭領域のアドレスを返せばよい。

変数系のものは、逆にRAM上のユーザ領域に場所を確保し、アドレスを返すようにする。ユーザ領域の初期化はcoldスタート時にRAM上ユーザ領域にコピーすればよい。

.userと.constでアドレスカウンタを2つ用意し、それぞれ別にインプリメントし領域を割り当ててゆく。.constは辞書本体(base.f)コンパイル後、辞書ダンプ前に値をセットする。.userはターゲット辞書で実行開始直後にRAM上に初期化する。

引き続き xx.def 上で試作を続ける。

 ||||
 |--|--|--|
 |.head|DICTTOP<br>DICTEND<br>DICTENTRY|定数。辞書先頭に領域確保。XXX_ADDRで領域アドレスを返す
 |.const|UP, S0, R0,<br>TIB|定数。領域は確保しない。XXX_CONSTで値を返す。base.fコンパイルまでに値を確定させる。
 |.user|DP,LAST,<br>STATE,DEBUG,<br>BASE等|変数。ユーザ変数領域に確保する。XXX_ADDRで変数アドレスを返す。ユーザ変数定義直後(user.fの中で)に値を代入する。
 ||||

ユーザ定義ファイル user.def 先頭に org/user_orgは含めていない。
makeuser.sh の第2, 第3引数で org user_orgを指定する。必須。

辞書先頭: ORG, ユーザ領域先頭: USER_ORG は定数として定義してみた。

 |||user.h|user.f|user.s|
 |--|--|--|--|--|
 |.head|辞書先頭|XXX_ADDRを#define<br>定義(アドレス値を持つマクロ定義)|ワードXXX_ADDRを<br>定義|`.dw`で値を保持、または辞書ダンプ直前にpost.fで値を設定
 |.const||(定義なし)|ワードXXX_CONSTを定義。値は`//`以後の式を用いる|(定義なし)
 |.user|ユーザ変数領域|XXX_ADDRでユーザ変数領域のアドレスを#define定義。|XXX_ADDR領域に`//`以後の式を評価して代入。|(定義なし)
 ||<img width=100>|<img width=500>|<img width=500>|<img width=500>|

makeuser.shが3種のファイルをそれらしく出力できるところまできた。次はホスト辞書ビルドとターゲット辞書ビルドだ。

xx.def をuser.def に戻して base.fロードまで動作した。途中Segmentation Faultしたが、ユーザ変数領域の初期化ができていなかったからだった。

分かったこと

* user.fで DP_ADDR, LAST_ADDRを辞書ヘッダからコピーするのはだめ。その前に`: DP_ADDR 0xf000 ;`した時点で辞書ヘッダの値とずれてしまう。C言語のテキストインタプリタ立ち上げる前に行う必要がある。
* 辞書ロード時(read_xfile)の最後、辞書ロード直後に行っている。適切な場所だと思う。
* ターゲット辞書をロードすると、LAST_ADDRが破壊される(ターゲット辞書のDICTENTRY_ADDRで上書きされてしまう)ので、read_xfileで行う前にCROSS_ADDRにホスト辞書LAST_ADDRの値を入れておく必要がある。
* DP_ADDR, LAST_ADDR以外のユーザ変数、初期値を手で初期化する必要がある。user.fに代入文を入れた。
* 今や、user.sでは辞書ヘッダ3つ
* 辞書イメージロードからの立ち上げには、ユーザ領域初期値のコピーコードを実行するようにする。これも辞書ロード時に行う。
* よって、辞書イメージダンプ時に、coldに最低限init_userを入れておく必要がある。従来はC言語でコピーしていたが辞書ヘッダにuser変数初期値を置く場所がなくなったのでこうなる。

うーん、結局、辞書ヘッダにユーザ変数初期値を入れておくやりかたの方がよさそうだ。1日触ってみたが以前のやり方がよいとなってしまった。

ただ、head, const, user 3種の区別が明確になり、ROM領域参照のみ領域とR/W必要なユーザ変数領域を分けて管理できるようになったことは進歩かも知れない。

## 決定版？

ホスト版辞書ダンプと再起動まで動作確認した。クロス版辞書ビルドはこれから、start_cross.fからデバッグ。

#### C言語版インタプリタ起動時

* 辞書バイナリ内の初期値ヘッダは完全ではない。初期値が埋まっているのは、`dict`, `here`, `last`(辞書3要素)、`COLON`, `SEMI`, `do_dolit`, `DP_HEAD`, `LAST_HEAD`だけ。
* テキストインタプリタ実行開始に先立ち、Xファイルロード直後に、`DP_HEAD`, `LAST_HEAD`を更新する(ヘッダ3要素から代入)。
* S0_HEAD, R0_HEAD, TIB_HEADを初期化。
* `DP_HEAD`から`END_ADDR`までのユーザ変数領域にコピーする。
* user.f内部で、`HALT_HEAD`, `COLD_HEAD`を初期化。
* ここで(`init_mem`)、辞書ヘッダのDP_HEAD以後をユーザ領域先頭にコピーする。
* `HALT_HEAD`にワードhaltのxtを代入。

#### 辞書ダンプ時

* `DP_ADDR`, `LAST_ADDR`を DP_HEAD, DICTEND_HEAD, LAST_HEAD, DICTENTRY_HEAD に書き戻す。
* この状態で辞書をファイルに書き出す。

これで`./cpnr -o cross8.bin dict.X user.f base.f dictdump.f`でダンプした cross8.binの動作を確認した。

base.fのバージョン文字列を`v0.91dev`に上げた。

#### バイナリ辞書起動時

* バイナリ辞書ロード時は、辞書ヘッダは完成しているとみてなにもせず
* ユーザ変数領域にコピーする。これで特に問題なく動いているようである。

## 仮想CPU名: nr1

としてみた。まだしっくり来ていないので変えるかもしれない。

## ヘッダ/ユーザ領域の初期化

C言語版処理系、辞書先頭アドレスだけを外から与えるだけで、ヘッダ領域とユーザ領域初期化ができるようにした。

* DP_HEAD, LAST_HEAD: 埋まっていればそれを使う。ゼロならば、DICTEND, DICTENTRYを使う。
* UP_HEAD: 埋まっていればそれを使う。ゼロならば 0xf000 を使う。
* S0, R0, TIB: 埋まっていればそれを使う。ゼロならば、それぞれ UP_HEAD + 250, 512, 256 を使う。
* ヘッダ領域をここまで仕上げたのちに、ユーザ領域にコピーする。
* コピー後、HALT_HEADがゼロならば、`' head`で辞書を引いた値を入れる。

cpnrのオプションに`--plain`を設けた。これを指定すると、「ゼロならばXXXを使う」を行わず、すべて辞書ヘッダ領域の値を使って起動する。これで引っかかると辞書バイナリの構築がうまくいっていないことが分かる。他CPU向けターゲットを作るときはこれを生かしたい。

## クロスコンパイル辞書が動かない。

'.'で命令0を実行しようとして止まる。

80b8を実行しようとしている。

80b8はホスト辞書の'qbranch'であった。
`s->d`の実行中にここに堕ちている。if文のコンパイルで80b8を入れているらしい

```
1f82 .head "s->d"
1f88 1f48  [link]
1f8a 1038  [code]
1f8c 1140 (dup)
1f8e 17ca (msb)
1f90 119c (and)
1f92 80b8 (:)
1f94 1f9e (s->d)
```

1f92の80b8は本来?qbranchのxtを入れてほしい。

`if`のコードを見てみると、

```
: if compile ?branch >mark ; immediate
```

`compile`のコードを見てみると

```
: compile r> dup cell + >r @ , ;
```

である。スレッドコードの次のxtをコンパイルするというもので、ホスト環境では当然8000番台のアドレスとなる。なるほど。

クロスビルドではcompileを使ってはいけない。

```
: if ' ?branch , >mark ; immediate
```

とすればよいかな。

## start_compile.fか？

start_compile.f終了時のユーザ変数のDP, LASTがA328, A30Cなのはおかしくないか？

## 現状(6/16)

[compile]をプリミティブにして`: if [compile] ?branch mark> ;`してみたが、だめだった。
辞書ヘッダにbranch, ?branch(と他compile引数になっているプリミティブ)を引いていれておくしか思いつかない。

## 空港でバッグ

if のコードがおかしい。というか、書いた通りにコンパイルしているので、書いたやつが悪い。

`[compile] ?branch`と書くと、定義中の辞書に`?branch`をおく。

欲しいコードは、コンパイル中にifに出会うとそこに`?branch`をおく、なので、`' ?branch ,`と書くべきだろう。

dump_entry: entry = 8A54, tail = 8A62
8a54 .head "if"[80]
8a58 8a3c  [link]
8a5a 8038  [code]
8a5c 80b8 (?branch)
8a5e 8a0c (>mark)
8a60 803c (semi)

`' ?branch ,`と書いてみた。`1 not found`とでた。`?branch`ではなく`if`の次の1を読んでいる。

`'`がimmediateになっていないのか？

## 高の原デバッグ

空港でデバッグしていたら搭乗最終案内で個人名晒されてしまった。格好悪い(^^)

高の原で次の曲が始まったり迷宮ボス攻略見たりしながらやった結果、

### immediateワードでcompileする

`: aho if 100 else 10 then ;`をコンパイルすると 0x80XXがコンパイルされる件である。immediateワードはホスト環境で実行される、`if`の定義で
`compile ?branch`していた。これだと、compile, ?branchトークンがならぶが、これらはホスト環境の辞書で引いた値を描く。あたりまえだが、どちらも0x80XXになる。

`if`はimmediateワードで、ターゲット辞書にコンパイルしているときも、`if`に出会うとホスト辞書のワード定義を実行する。この中に?branchは0x80XXで焼き付けられているので、ターゲット環境でビルドした辞書の定義には0x80XXが混じらないのだが、ifを使うワードをコンパイルすると(ホスト環境のif定義が実行されるので)、そこに0x80XXが混じってしまう。

ターゲット環境ビルド時に、ターゲット環境でビルドした`if`定義を実行できれば良いのだが、それができれば苦労しない。z80の機械語をC言語仮想機械で実行できないからだ、当たり前だ。結局、「ホスト環境で定義したifを実行する際に、ターゲット辞書ビルド時は?branchはターゲット辞書のxtをコンパイルしたい」を「ホスト環境でビルドしたifを実行して」実現するとするなら、?branchのxtを変数に格納しておいて、ターゲット環境のビルド開始後にその変数の値を`' ?branch`に書き換えると行ける気がする。

事実これで動く。

* ユーザ変数領域は最初に確保しておく。
* base.fの中で`?branch`定義以後、immediateワードで使用するまでの間にxtを入れておく。xtは`' ?branch`で取得して良い。`'`はターゲット辞書をサーチするので。
* 使用箇所で、`vQBRANCH @ ,`と書いてコンパイルする。

1. ユーザ変数で`vQBRANCH`を定義する。user.defにエントリを追加する。

```
    .huser vQBRANCH
```

2. 別途`huser.f`にユーザ変数アドレスを定義しておく(makeuser.shが勝手にやってくれる)

```
: vQBRANCH         0xf02a ;
```

3. base.fで、`?branch`定義後にxtを取り出し、`vQBRANCH`に保存しておく。

```
' ?branch vQBRANCH !
```

4. `compile ?branch`と書いてある箇所をすべて`vQBRANCH @ ,`と書き替える。

base.fを起動してのホスト動作で動作することは確認した。バイナリ辞書で起動するときには、`' ?branch vQBRANCH n!`に相当する処理がないので、`: aho if 1000 else 10 then ;`のコンパイル結果は、?branchのxtに相当する箇所すべてが0000になってしまう。

バイナリ辞書版の起動時にこれらベクタ変数を初期化しておく必要がある。

## ベクタ立てても元の木阿弥だった。

最初の状態に戻ってしまった。

* ターゲットビルド時に`if`, `else`, thenは期待通りコンパイルできている。
* : aho if 100 else 10 then ;で、?branchに80c8が入っている。

たぶん本質を理解していない。

1. ホストビルド時に : if ... ; 定義
2. ホスト辞書をダンプ
3. ホスト辞書+C言語インタプリタでターゲット辞書をコンパイル: : if .... ;をコンパイル。
4. 同上: : aho if 1000 else 10 then ;をコンパイル
5. ターゲット辞書をダンプ
6. ターゲット辞書をロード: : aho if 1000 else 10 then ;をコンパイル

それぞれについて、ifのコンパイル、実行を表にして整理する。


「ホストビルド」「ターゲットビルド」それぞれについて、「外で実行」「コロン定義中でコンパイル」「コロン定義中で即値実行」「コロン定義中で[ ... ]で実行のそれぞれについて、あるべき姿(ホスト辞書で実行、ホスト辞書でコンパイル、ターゲット辞書でコンパイル)を整理しておくべきだな。

## does> クロスコンパイル版動いていない(6/19)

クロスコンパイル中はdoes>もホスト版が動いている。「実行時のdpの値」を見てコンパイルするように変更する必要がある。その前に、Dr. ChenのfigForth本見て考えよう。

## 図を改訂整理した結果、わかったこと

<figure>
<img src="img/fig04-cpnr_crossdev_desc.png">
</figure>

以下ぐだぐた書くが、要するに、ベクタを使って今までうまく行かなかったのは、「ホスト環境ビルド時に参照する(ホスト環境の)ベクタを、ターゲットbase.fコンパイルについて書き換えてゆく」になっていなかったからと分かった。

1. ワードifが?branchをコンパイルする際、ベクタを使う。これは必要条件。  
   `'`quoteを使った場合、「文字列からxtへの変換はコンパイル時1回のみ」なので、ホスト環境ifが?branchのxtをコンパイルするとき、「後で(ターゲットコンパイル時に)?branchのアドレス(xt)を切り替える」ことができないから。後で切り替えるためには、「ベクタから?branchのxtを取りコンパイルする」「ベクタの値を、ターゲットコンパイル開始時に切り替える」しかない。
2. ベクタはホスト環境コンパイル時に確保される領域を用いる  
   ターゲット環境でword(他、ifを使用しているワード)をコンパイルする際には、ifがimmediateワードとして実行される。この実行はホスト辞書のifが実行される。全アドレス参照はすでに解決済なので、ベクタのアドレスもホスト環境から見えるところしか使えない。ホスト環境ビルド時には、ターゲット環境のアドレス(ターゲット辞書の開始位置)は決められないのでこうなる。  
   今はそうなっていない(ターゲット辞書ヘッダを指している)ので、ここは修正必要。
3. base.fで、ベクタの値でコンパイルするワード(?branch, branch, (do), (loop)など)を定義した直後にベクタに値を書き込む。  
   ホスト環境でifを定義して、そのifを参照(使用)する前までにベクタに値を設定しておく必要があり、間違いを防ぐためにはベクタ先にしたいワードを定義した直後にxtを設定しておくのが良いだろう。
4. ターゲットコンパイル切り替え時に、ベクタの先を書き換える。  
   ホスト環境定義のためのbase.f読み込みは完了しているので、ベクタすべて定義されているはず。  
   dict.Xで定義するワードについては、ターゲットコンパイル直後(target_dict.fロード済のはず)に検索し書き換える。  
   base.fロード中は、ベクタ書き換えコードが適宜埋め込まれているので、そこでターゲット辞書からxtを得てベクタを書き換える。書き換え対象のベクタはホスト環境のものである必要がある。
5. ターゲット辞書にifをコンパイルする際には、その中のベクタアドレスもターゲット環境のものを指すように配慮する必要がある。ターゲット環境コンパイル開始時にベクタの定義を上書きする(同じvQBRANCHという名前で今度はターゲット環境のアドレスを定義する)  
   ※チェック(1): ターゲット版ifのダンプにより目視確認  
   ※チェック(2): base.fにテスト用ワード`: aho if 100 else 10 then ;`を入れておき、コンパイルさせてみる。ターゲット環境のahoをダンプしてみる。 すぐ後ろに`last dd`でよいと思う。
6. ビルドされたターゲット環境実行開始の際には、ターゲット環境のベクタを初期化しておく。  
   クロスコンパイル完了、dictdump時のホスト環境のベクタの値はすべてターゲット環境を指している。よって、ダンプ前にこの値をターゲット辞書ヘッダにコピーしておき、ターゲット環境起動時には自動的に参照できるようにしておく。

ベクタ領域は辞書ヘッダ先頭に取るか、ユーザ変数領域に取るか。RAM領域に置く必要があるのならユーザ変数領域に取るべき。が、自前のif/else/thenやdo...loopを組む可能性は低いので、辞書ヘッダ先頭にとってもよい。とすると、

7. ベクタ領域は辞書ヘッダ先頭に取る。user.fで.headエントリとして定義しておけばよい。
8. ホスト環境立ち上げ時、辞書イメージロード時にvQBRANCH, vBRANCHに値を設定しておく(この3つはプリミティブとして最初のバイナリに定義されている)
9. 以後、base.fを読み込んでホスト辞書を増やしてゆく過程で、都度、ホスト辞書ヘッダのベクタにxtを設定してゆく。
10. クロス開発環境ではホスト辞書ヘッダ先頭を、base.fを読み込んでターゲット辞書を増やしてゆく過程で、ターゲット辞書を指すxtに書き換えてゆく。
11. ターゲット辞書ビルド時には immediate ワードを「地の文」(コロン定義外のワード実行される領域)で実行してはならない、ホスト仮想CPUで実行できない機械語を実行する羽目になる。
12. また、クロス開発辞書はROM焼きしてはならない。起動後に該ベクタ領域を書き換えるからである。仮想CPU環境はall RAMで組まれているのでこの制約は障害にならない。
13. user.defの.huserエントリは廃止して、.headエントリを使うようにする。

これで行けるはずだが、以前「これで動く」と書いた時と変わっていない気がする。それでもやるしかない。

## うまくいった(6/19)

これで動いたようだ。if-else-then は動作した。do-loopは未調査だが多分大丈夫だろう。

variable, constantがまだ駄目だ。`does>`で生成されるコードに8XXX番台のxtが混じっていた。次はこれのデバッグとなる。'abort ベクタがvariableだが、それが動かない。

`does>`も(does)をベクタ化した(vPDOES)。これで variableは動作するようになったが、constantはだめだ。variableと同じ動作になる。

あと、`cold`も動作していない。

## constantデバッグ(6/19)

修正後のコードは以下のようになる。修正前は、`COLON_HEAD @ cell + ,`だった。

```
: does>
   vPDOES @ ,
   SEMI_HEAD @ ,
   0x7005 ,       \ m_startdoes
   COLON_HEAD @ ,  \ colon bincode
      \ now COLON_HEAD holds not xt but routine itself,
      \ so no need to add two to it.
   ; immediate
```

COLON_HEAD導入前には、COLON_HEADはワードcolonのxtを指していた。バイナリコードはその2つ先なので、`cell +`があったのだ。

今はCOLON_HEADはdocolルーチンを直接指すアドレスを格納しているので、+2は不要なのだ。

## coldデバッグ(6/19)

cold.f dictdump.fしてnr1.bin起動すると命令0000実行で停止する。

cold.f dictdump.f 外して`variable foo`すると、

```
33c4 .head "foo"
33ca 33b4  [link]
33cc 95d0  [code]
33ce 33cc ()
```

95d0が混じっている。これではいけない。


## does> 動かした(6/20)

does> 動作を一から考え直した。

```
: constant create , does> @ ;
```

```
2646 .head "constant"
2650 260e  [link]
2652 1050  [code]
2654 2618 (create)
2656 1900 (,)
2658 19a2 ((does))
265a 1054 (semi)
265c 7040 ()        // m_call 105c
265e 105c ()
2660 1116 (@)
2662 1054 (semi)
```

```
1050 7002 COLON:    m_colon1
1052 8004           m_jmp     NEXT
1054 1056 SEMI:     .dw .+2
1056 7006           m_semi1
1058 7003 NEXT:     m_next1
105A 7004 RUN:      m_run
105C 703F DODOES:   m_exch
105E FFF0           m_jmp   COLON
```

* `100 constant foo`の場合、
* does>は、
  + `(does)`を置いて、
  + `semi`を置いて
  + `m_call DODOES`を置く。

constantオブジェクトを生成する際に、`(does)`を実行する。

`(DOES)`は、オブジェクトのCFAを`m_call DODOES`(265C)を指すように書き換える。constant, variableそれぞれ別の機械語ルーチンを指す。`(does)`の呼び出し元(rsp @で得ている)の2セル後ろをCFAに埋めている。2セル後ろで1セル空くが、ここには`SEMI`を入れるのである。

`m_call DODOES`ではDODOESを実行する。jmpでなくcallなのは、この呼び出し元のPCアドレスが実行に必要だから。jmpでは呼び出し元のアドレスは失われてしまう。手っ取り早く呼び出し元のアドレスを得るためにcallを使ったというところ。

よって、別のレジスタにPCを保存しておいてjmp命令を使うというのもありだ。

DODOESに入ってきたところで、スタックトップに呼び出し元の次のアドレス、この場合は2660, スレッドコードの先頭があり、WAにはオブジェクトのPFAがある。スレッドコード実行開始時には、ちょうどこの逆、スタックトップにオブジェクトのPFA, WAにスレッドコードの先頭を入れておきたい。よって、最初の命令がm_exchとなっている。

m_exchは、`EX (SP),WA`である。上で説明した動作をC言語的に行っている。

## ターゲット用inner.s, primary.s

ターゲット用inner.s(内部インタプリタ)は手で生成する。DODOESを追加したときにターゲット用をコピーしなければ、DODOES未定義エラーが出た。

ターゲット用primary.sも手で書くことになる。忘れていたのでここにメモを残す。

## 次のアクション(6/20)

これでクロスコンパイル環境が動き出した。いよいよ実CPUをターゲットとした開発を始めたい。最初はZ80でRAM40基板ベースで行く。これで動作確認後、emuz80版を作成し広く公開する。この辺で時間切れのはず。

## ターゲットビルド(6/20)

coldが起動しない。init_dict実行中にスタックに定数が乗らない。base.f版テキストインタプリタが動作していない。cold起動時に9XXX番地の命令を実行しようとして止まる。C言語版でどうか、から。

## クロス環境でvariable(6/21)

クロスビルド中にvariable fooすると、ターゲットfooのコードフィールドにはホスト側のvariable does>のアドレスが刻まれる。

これは、variable 実行時にターゲットfooのエントリを組んでゆくが、このコードフィールドに書き込む値(variable does>の直後のアドレス(機械語callが置かれている))計算がリターンスタックから得ている。リターンスタックには(does)の呼び出し元、つまりvariableコロン定義の最後の方の値があり、そこから4足してdoes>直後の値を計算している。ホスト環境のvariableを実行しているので、does>直後のアドレスもホスト環境のアドレスを得る。それをターゲット環境のfooのcfaに書くのでこうなってしまう。

variableをクロス環境でターゲットfoo定義に適合させるには、does>を使用するワードごとにdoes>のターゲット位置を得られるようにしなければならない。ターゲットvariable定義のdoes>直後のアドレスはターゲットvariableコンパイル時に覚えさせる必要がある。ちょっとややこしすぎる。

base.fでvariable使用を禁じて、ユーザ変数を使うようにすれば問題は解決する。明らかに負けだが、variableをクロス環境対応にすることでvariable自体がかなり複雑になりそうで、それはそれで腰が引ける。

base.fでvariable使用しているのは、

```
variable 'execute --> vexecute
variable 'error   --> verror
variable 'abort   --> vabort
variable dpl
variable warning
```

なので、ユーザ変数を5つ増やすことにする。

## 

これでも nr1.bin, やはり9XXX番台の命令を実行しようとする。
abortの定義中の文字列直後の2命令が

```
2a0e .string 21 "abort not defined yet"
2a24 989e ()
2a26 91a4 ()
```

これ、count, typeだな。

```
: ." \ ( --- ) ... print the string
   state @ if
      [compile] ["]
      ' count 0x57 .ps ,
      ' type ,
   else
      [char] " word count type
   then
   ; immediate
```

クロスコンパイル時にコロン定義の中で`."`を使うと、ホスト側スレッドコードが実行される。

ホスト側スレッドコード`."`では、`' count`, `' type`は文字列xt変換はホスト環境で実行済で、ホスト側xtをリテラルとしてスタックに載せる処理が実行される。つまり、これに限らず、一般的に `' xxxx`のコードもクロス環境では動作しない。使えないとなる。

ここまでくるとユーザ変数に取るというのもしんどい。辞書を切り替えてクロスコンパイルするやり方をやめて別のやり方にするか。

## ホスト辞書を構築してからターゲット辞書にコンバートする

現在でもホスト環境でビルドは問題なくできている。ホスト環境とクロス環境の違いは、クロス環境では、辞書のプリミティブがホスト環境で実行できないことになる。つまり、z80コードを含むdict.X(z80_dict.f)をロードして、このプリミティブを実行しながらターゲット環境の辞書をコンパイルできないということ。

プリミティブ辞書部分を、各エントリのサイズをターゲット環境のプリミティブワードに合わせてビルドし、ホスト用プリミティブ辞書を再構成すれば問題ないことになる。

* ターゲット用dict.sを書く(Z80アセンブリ言語で)
* これをアセンブルして各エントリの先頭番地を確立する。
* C言語仮想CPU機械語エントリを、この先頭番地に合わせて「伸ばして」ターゲット用プリミティブ辞書を構築する

仮想CPUエントリは1命令で構築されているので、Z80機械語エントリのコードフィールドを(SEMIを除き)2バイト以上にしておけば大丈夫。

* ターゲット用プリミティブ辞書を./cpnrにロードして、user.f base.f cold.f dictdump.f をロード・実行すると、プリミティブワード部分は偽物だがターゲット用辞書ができる。
* 先頭を、あらかじめ作っておいたターゲット用プリミティブ辞書につぎはぎ入れ替えする。

こんなところかな。

## クロスコンパイルの手順

* ターゲット用 primitive.sをコーディング・アセンブルする。
* 各辞書エントリの先頭(パラメータフィールド、機械語本体が置かれる場所)を、対応する仮想CPU機械語命令に置き換える。
* 置き換えた辞書をX形式にしてロードし、user.f base.f cold.f dictdump.f をロード実行する。

これでターゲット用辞書ができる。

## いや`'`の定義を変えようよ

クロスコンパイル時に、`' xxx`を含むワードをホスト辞書定義で実行する際に、今は、実行前に(コンパイルの際に)ホスト辞書を検索してxtを焼き付けているが、実行時にターゲット辞書を検索してxtを探すようにすればよい。

そのために、文字列をリテラルとしてホスト辞書定義に置き、その後ろにfindを置くとよい。これで、ホスト環境ビルド時には文字列を保持し、ターゲット辞書クロスコンパイル時に保持した文字列を使ってターゲット辞書を検索できる。

