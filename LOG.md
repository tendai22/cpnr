# cpnr実装メモ

cpnr(A C Portable narrowroad interpreter)設計・実装の過程を記録し、C104同人誌ネタを集積する。

## 1プリミティブ1命令の仮想CPU

仮想CPUなので、PC, SPはじめForth処理系に必要なレジスタを持ち、PCをインクリメントしながら、「機械語命令」をフェッチ実行するエミュレータを作る。

最初はTILの仮想CPUの命令をそのまま実現しようかと思ったが、ソフトCPUなので、機械語のビットパターン構成を持つ必要はない。ビットパターン構成はハードウェア上の制約によるからである。

また、メモリとレジスタ間の転送もこだわらなくてよい。スタック経由でのデータのやり取りがメインなので。

ここまで考えて、**Forth1ワードを1機械語命令**としてもよいのではないかと思いつく。こうすることで、プリミティブはすべて、2命令(プリミティブを構成する命令一つとNEXT命令の2つ)で実現できる。

各機械語命令はC言語で記述できる。加算減算プッシュdropのような単純なワードも、`ACCEPT`(行入力)、`WORD`(空白文字でワードを切り出す)、`FIND`(ワード文字列で辞書を検索し、定義の有無を探す)、`NUMBER`(ワードをバイナリ数値に変換する)もすべてC言語で記述できる。

最初はC言語多めでForth処理系を作り上げてから、C言語部分をスレッドコード化(コロン定義化)して減らしてゆく際も、プリミティブ単位でスレッドコード化すればよく、移行の管理もやりやすい。

機械語命令化するワードを以後、プリミティブと呼ぶ。プリミティブは2種類ある。最後までプリミティブのままのワードと、最初はC言語命令だが、最終的にはコロン定義で置き換えられるものである。

#### 最終的にプリミティブのままのもの

他の実CPUに移植する際にはターゲットCPUの機械語命令で表現することになるもの。

1. 内部インタプリタ(NEXT,RUN,COLON,SEMI,EXECUTE)  
2. 加減乗除・ビット演算
3. スタック操作(PUSH,DROP,ROT, ...)
4. メモリアクセス(!, @, C!, C@)
5. 文字列処理(.")、メモリ転送(CMOVE, ...)
6. 出力処理(# #S <# #> ...)、入力(KEY, ?KEY)
7. アボート(ABORT)...大域ジャンプ機能、C言語でsetjmp/longjmn使う部分

#### 最終的にスレッドコード化するもの

コロン定義で再定義される。ターゲットCPUに「移植」せずともそのまま利用可能となる。

5. コロン定義(コロン、セミコロン、IMMEDIATE)
7. 定義語(CREATE, VARIABLE, CONSTANT)、
6. 制御構造(IF ELSE THEN, DO WHILE, ...)
8. 外部インタプリタを構成する単語(ACCEPT, WORD, FIND, NUMBER)
9. 外部インタプリタ自身(QUIT)

## 外部インタプリタ、内部インタプリタ、仮想CPU

外部インタプリタは当初C言語で記述する。ACCEPT, WORD, FIND, NUMBERに相当する処理をC言語で記述し、外部インタプリタはそれらを使ってループを構成する。

コードを書きながら感触を見て組んだ結果として、

    monitor ⇒ 外部インタプリタ ⇒ EXECUTION 
    ⇒ 仮想CPU実行 ⇒ debugger

とした、仮想CPU起動の前処理として辞書検索して得たxt(Execution Token)をスタックに載せておいてEXECUTEプリミティブのコード部のアドレスをPCに入れた状態で仮想CPU実行を開始する。

簡単なプリミティブなら1命令実行後NEXTを実行して終わる。複雑なプリミティブならそれなりにスタック操作したりする。スレッドコード部分なら、COLON命令のあとスレッドを構成する各ワードを実行し最後にSEMIを実行して呼び出し元に戻る。

最上位はmonitorである。基本的にrun命令`...`(ピリオド3つ)しか受理しない。実ハードではコンパニオンCPU内部のプログラムとなることを想定している。シリアルのダウンロード、ブレークポイントの設定機能が入る予定。

外部インタプリタ内部ではC言語記述の処理を実行し、最終的には辞書上のコードをスタックに積んだ状態で仮想CPUが動き始める。

仮想CPU内部では、命令のフェッチ・実行の合間にブレークポイント(予め登録しておいた仮想マシンアドレスとPCを比較し、同じであれば停止する)、HALT機械語命令を実行したところでいったん仮想CPU実行(do_machine)を終了し戻る。C言語記述の外部インタプリタは、次の実行サイクルを開始し、WORD/ACCEPTの実行から始める。

## 最初の立ち上げ

* monitor, 外部インタプリタ, EXECUTION, 仮想CPU実行,はそれなりに組んでおく。
* 仮想CPU実行は常時シングルステップとして、デバッガを呼び出す。
* デバッガは仮想CPUレジスタダンプとスタックダンプのあと、キー入力待ちとなる。キー入力するとデバッグを抜け、次の機械語命令実行に回る。
* 外部インタプリタ最初はWORDとEXECUTEのみを実装する。NUMBERはスタブ、FINDは常にテストワードのxtを返すスタブとする。
* 辞書エントリは1種類テストワードのみ、機械語命令を複数並べ、最後にNEXTを置く。

## WORD

WORDプリミティブのコードをC言語で書いている。入力ストリームの定義と設計が問題になった。

* `WORD`が現在読み込んでいる文字は`BLK`, `>IN`の2変数で決まる。
  + `BLK` == 0ならメッセージバッファ`S0`中のオフセット`>IN`の文字
  + `BLK` != 0なら、`BLK BLOCK >IN @ +`の位置の文字。`BLK`はブロック番号を保持する変数。`BLOCK`でブロックバッファ上に該ブロックの内容を読み込み、ブロックバッファ先頭のアドレスを返す。そこにオフセット`>IN`を足したアドレスがカレントポインタとなる。

この場合、入力メッセージバッファ`S0`(データスタック最後尾の次、昔のForthではデータスタックのすぐ上位に入力メッセージバッファを置いた)の有効長、ブロックバッファの残り文字数が明示的に表れてこない、がこれは必ず必要になる。何らかのシステム関数(例えば`getchar`)の内部で管理するのが適切だろう。末尾に達したらEOFを返す。Forthの場合は、バイト0を返すというのでよさそうだ。

EOFを返した時に入力ストリームを再初期化する必要がある。以前のnarrowroad-m68kでは`getchar`内部で行おうとしていたが、これは外に出した方がよさそうだ。

ロジックは「EOFが来たらキー入力を入力メッセージバッファに読み込み`>IN`をゼロに、残り長さを`getchar`内部管理の変数にセットする」とする。

ブロックバッファからソースコードを読み込んで解釈実行するのが`LOAD`であるが、これは入れ子で呼び出される。あるブロックの解釈が終わると、`LOAD`コマンドの次に実行を移す。とすると、`LOAD`のネスティングを管理せねばならないが、さてどうするか？

データスタック上でネスティングを管理することが可能かどうかよくわからない。ブロック間でデータスタックにものを置かないルールを課せばなんとかなるかもしれない。

個人的にはブロックバッファは使うつもりがないので、初期立上では内部バッファを読み切ったらキー入力としましょう。あと、`S0`と`PAD`はHERE+36byteと。

内部バッファ、エミュレータではファイル引数を読み込んで入力ストリームにつなぐ、実機ではFLASH領域のアドレス。

ACCEPTが、EOFが返ったあとのリダイレクト(`getchar`が次のデータを読み込めるようにする)。

プロンプトは、キー入力の入力バッファすべてを読み切って空になったときにその行に出す。OK出して改行、ユーザ入力は次の行の先頭から見える。となっているようだ。

## FIND

 FINDの動作を確認するためには、辞書のバイナリイメージが必要である。辞書ファイルをアセンブリ言語に変換し、アセンブラ(*.s)とバイナリダンプ(*.Xファイル生成)ツールを作成した。

 辞書には、コードワード、しかも1機械語命令だけを含むコードワードを入れた。これを用いてC言語で外部インタプリタを作成し、ソースコードをコンパイルしてコロンワード(スレッドコード)を生成できるようにする。これが次の目標である。

 辞書エントリのリンクをたどって文字列比較するところは平明だった。strncmpが使えることは見通しの良さを得た。

 xt, 実行トークンの定義で迷った。辞書エントリのコードフィールドのアドレスを含むワードなのか、それともその中身のワード(そこに間接ジャンプする)のかである。結局TIL本の例のコードを見返した。

    Location   Mnemonic Instruction  Comment  

    0140       COLON   PSH I -> RS  
    0142               WA -> I  
    0144               JMP         ; Jump to NEXT  
    0146               0104          

    0100       SEMI    0102        ; Code address of SEMI  
    0102               POP RS -> I  
    0104       NEXT    @I -> WA  
    0106               I = I + 2  
    0108       RUN     @WA -> CA  
    01OA               WA = WA + 2  
    010C               CA -> PC  

    0050               7E          ; Dictionary  
    0052               XE          ; header  
    0054               LA          ; for EXECUTE  
    0056       EXECUTE 0058        ; Code address of  EXECUTE  
    0058               POP SP -> WA
    005A               JMP         ; Jump to RUN
    005C               0108  

`EXECUTE`のところ、スタックトップのワードの値は、RUNの先頭でそのアドレスを取り出しそこにジャンプする。つまり、辞書エントリのコードアドレスをスタックに積めばよいことが分かる。

    STAR(code_addr(entry));

ではなく、

    code_addr(entry);

をスタックに積めばよい。

## RUNが違うのではないか?→やっぱり違わない！

do_executeが最初動かなかった。1回余分にポインタを手繰ってしまっていた。

xtが次に実行するワードのコードフィールドなので、１ワード実行後、次のワードhaltをスレッドコード的に実行させようと考えた。それで、xtをipに入れたらよいと思っていた。

ユーザ変数HALTにxtを置くようにしていたので、ユーザ変数HALTの値をipに入れればよいのだろう。

        cx->ip = STAR(HALT_ADDR);

と考えたのだが、これで実行すると、機械語先頭をアドレスとしてフェッチ後飛び込んでしまった。

もう1回、スレッドコード実例も見ながら考え直した結果、「ipは、次に実行するワードのコードフィールドを指すアドレスを置いた場所を指している」のだった。

今の場合、たまたま、ユーザ変数HALTにxtを置いており、その置き場のアドレス、つまり、HALT_ADDRをipに入れればよいのだ。STARででレファレンスするのではなく、HALT_ADDRを直接ipに入れておく。内部インタプリタNEXTでは、IPの指す先にある「次のワードのCAのアドレス」を取り出して、その指す先にジャンプするので動作する。最初、TILの記述が間違っていると思ったのだが、そんなわけはない。間違っていたのは、私のdo_executeの作り方だった。久々に「mallocにバグ無し」という名言を思い出したことだった。

    void do_execute (context_t *cx)
    {
        // start inter interpreter
        cx->wa = do_pop(cx);
        // code of m_run(cx);
        cx->ca = STAR(cx->wa);
        cx->wa += 2;
        cx->pc = cx->ca;
        cx->ip = HALT_ADDR;
             // ipはxtの置き場を指すようにする。
             // それはアドレスHALT_ADDRだ。
        // do infinite loop
        do_machine(cx);
    }

do_machineはm_halt命令を実行するとdo_machne内の無限ループを抜けて戻ってくる。ワード"halt"(機械語命令m_haltだけを実行する)を定義して、そのコードフィールドアドレスをユーザ変数HALTに入れてあるので、これで動作する。

    1016 04     .head "halt"
    1017 68
    1018 61
    1019 6C
    101A 74
    101B 20
    101C 1008     .dw    entry_000
    101E 1020     .dw     .+2
    1020 C001     m_halt
    1022 C003     m_next

ユーザ変数HALTの値置き場のアドレスは、400A番地(マクロHALT_ADDR)である。ここには101Eが入っている。

    IP:400A番地の内容(101E)をWAに代入
    WA:101E番地の内容(1020)をCAに代入
    CA:1020番地にジャンプ(== CAをPCにmoveする)

とNEXTは動作する。

これで内部インタプリタも動作することが分かった。コロン定義を実行させて初めて完結するが、最後のEXIT以外は大丈夫そうだ。

次はコロン定義が書けるようにする。':', ';'を定義するが、その前にCREATEを用意する。

コロン定義が書けるようにすると、C言語1命令1プリミティブの用意は終わり、いよいよコロン定義だけを用いてForth処理系を書きおろしてゆく。

## コロン定義のコンパイル

コンパイルを実現するために必要な処理は3つある。

* ワード2個、コロンとセミコロン
* mainloop(外部インタプリタ)の「ワード実行」を「コンパイル」に切り替える
* 即時ワード(IMMEDIATE)処理

## ワード実行とコンパイルの切り替え

これは変数`STATE`の値により切り替える。変数名を明示的に書くことはなく、`[`, `]`の定義中で参照・書き換えるようである。我々は`[`、 `]`をプリミティブ(機械語)とするので、内部インタプリタ内部とこの両ワード定義内で参照できればよいということになる。

内部インタプリタも`[`、 `]`もコロン定義するつもりなので、ユーザ変数を定義する。コロン定義中では、`_state`でアドレスを返すワードとしてプリミティブを用意し、以後、それを使用する。

プリミティブとしては、コロン、セミコロン内部で切り替えるところで始める。`[`、 `]`, ワード`STATE`はコロン定義でつくる。実体としてユーザ変数_STATE(アドレスSTATE_ADDR)を用意する。

## :(コロン)と;(セミコロン)

コロン定義では、do_createした後にSTATE_ADDRに1を書き込むだけである。

セミコロン定義では、SEMIの実行トークン(xt)を辞書エントリに追加した後でSTATE_ADDRに0を書き込む。

SEMIの実行トークンは起動時に変数SEMI_ADDRに入れておく。

## 内部インタプリタが動作しない

プリミティブ(opcodeのC言語記述)の間違いが多かった。

* opcodeが動作しない。これは機械語(do_machine)の誤り
* opcodeエントリの最初で機械語命令に飛ばない。
* 飛んでも停止しない...executeの戻り先に「機械語ルーチン」ではなく、「機械語ルーチンのアドレスを入れた場所」をIPに入れておかねばならなかった。

今回良かったのは、COLON, SEMI, NEXT, RUNの機械語命令をTILに記載のものがあり、迷ったらそれに立ち返ることで方向を見失わなかったことだった。辞書エントリのコードフィールドのアドレスは「機械語ルーチン」のアドレスだが、コロン定義の2番目以後のアドレスは、「ワードのコードフィールド」であること。これを見失って道に迷いかけた。narrowroad-68kではここを自分だけで考えて道を踏み外し、気が付けば直接スレッドになってしまっていた。今回も、executeで実行できないとき、「アドレスを機械語命令として実行しようとした」ため、NEXT, RUNのでレファレンスを外しかけてしまった。TILのコードを前に頭を冷やして対応することで間接スレッドで完遂することができた。

要点は、
* 辞書エントリのコードフィールドのアドレスは「機械語ルーチン」のアドレスだが、
* コロン定義の2番目以後のアドレスは、「ワードのコードフィールド」であること。  
  この先のワードをフェッチして、そこにジャンプするのだ。
* xt(execution token)は「ワードのコードフィールドのアドレス」であること。

コロン定義の最初のアドレス(コードフィールド)と２番目以後のアドレス(パラメータフィールド)は意味が違うのだ。本で何度も見ているこの文言だが、いざ自分でコードを書きデバッグすると簡単に道を失ってしまうことを体験できたのは収穫だった。

## コードフィールドに入れるルーチンアドレス

当初、opcodeとして、COLON, NEXT, RUNのコードワードを定義して、辞書ロード後にこの３ワードのxtをdo_findで見つけて、それをユーザ変数に代入していた。あとでコンパイルの際に、新しいワードのコードフィールドに書き込むためである。

新しいコードフィールドに書き込むアドレスはこれではいけない。これはdo_findで当たったアドレスを入れてはいけない。この3ルーチンは機械語ルーチンとしてワードエントリとは別物として扱うべき。

C言語版Forth処理系としては、辞書の中にこれら機械語ルーチンも含めておきたい。辞書バイナリと一体化して、バイナリロード１回で済ませたいからである。辞書バイナリは、最初3ワードが辞書エントリのとりつき口(LAST, H/HERE)としている以外はすべてエントリの列である。

EXECUTEはxtを用いて起動するので、辞書エントリだけしか呼び出せないと考える。定義語の定義でコンパイル時にCREATEの後にコードフィールドに書くアドレスにも要注意。DOES>の後ろのコードを実行させたいのだが、ここがトークンスレッドなので、m_colon命令を置いてそこを指すようにする必要がある。

NEXT,RUNを分けているのはそれが理由かもしれないという気がしてきた。定義語で新しいワードを作ると、そのワードのCFAにはm_colonを置いた場所のアドレスを置くが、その中でIPをIP+2してはいけない。スレッドコードは別の場所(おそらく、元の定義語のパラメータフィールド後半)にあるからである。m_colonとは別の機械語ルーチンが必要そうだ。

改めてみていると、そうでもないか。EXECUTEはNEXTを呼び出さずにRUNを呼び出している。あー、これはスレッドコード中から呼び出すからかな。RUNは間接参照ジャンプで、WAがCFAを指すアドレスを保持している前提で作られている。NEXTは、このCFAアドレスをIPの先から得る。すなわちスレッドコードの実行なのである。EXECUTEはスタック上からxtを得るからこうなっているのだろう。また、スレッドコード中にEXECUTEを含めることができるように、EXECUTEのアドレス自体には .+2の定数が置かれている。これはコードワードのCFAに置かれているものと同じ。

ちょっとわかってきたかな。

* NEXT: スレッドコードの次のトークンの実行(IPの先からxtをフェッチして、IPポストインプリメントしつつxtにジャンプ(==RUNと同じ))
* RUN: 機械語的間接ジャンプ(xtアドレスをWAに入れて飛び込む)
* COLON: IPをリターンスタックにプッシュして、新スレッドコードの先頭をIPに入れてNEXTへ
* SEMI: リターンスタックからIPに戻してNEXTへ

機械語ワードの最後はEXITと呼ぶが、これは、(機械語ルーチンの中で使わなかった)IPをWAに入れてRUNだな。こうして書き下してみれば単純明快なのだが、1度では肌になじまないのがこわいところ。今後のターゲットCPUの移植でまたハマるだろうがやむを得ないな。この原則を見返して道を踏み外さないようにしよう。

TILの仮想CPUでWA, CAレジスタがあるのが面白い。おそらく、CFAに置かれたルーチン(COLON==doLIST, doVAR, doCONSなど)は自分のパラメータフィールドを知るのだろう。WAが+2されているので、パラメータフィールドのアドレスはWAが保持している。doVAR, doCONSで変数の置き場所はここから知ることになりそうだ。

## 整理

内部インタプリタで整理する。

* word_mem(addr) -> STAR(addr)と改名した。ターゲットメモリのaddrの値を取ってくるのだが、星なので左辺値でもあり、STAR(addr)に代入できる。ワード単位の処理。ちなみにバイト単位の処理では、mem[addr]がそれに相当する。バイト実ポインタの取得も &mem[addr]と書く。今のところ、ワード実ポインタを得てバリバリワード配列処理をすることにはなっていない。

* :(colon), ;(semicolon)と、メモリpeek, poke (C@, C!, @, !)と加減乗除が少々あれば、インタプリタは全部かけるんじゃないかという気がしているが、ひとつ欲しいものがある。それは `DOES>`である。これは定義ワードで用いられる。コンパイル時にエントリを作る際の挙動だけでなく、出来上がったワードを実行するときの挙動も記述できるというものである。変数、定数、配列などもこれがあれば構成することができる。

## `DOES>`

    : FOO CREATE ..(1).. DOES ..(2).. ;

と書く。(1)部分が通常のコロン定義同様に、FOOの定義、FOOを呼び出したときに実行する内容である。FOOを使うときは、

    1 2 FOO BAR

のように描き、FOOの前の1 2がパラメータ((1)で使われるものもあれば、(2)で使われるものもある)で、FOOはそれを解釈してワードBARを作る。ワードBARを実行すると、そのたびに(2)の部分が実行される。

例えば、変数を定義するVARIABLEは、

    : VARIABLE CREATE ..(1).. DOES> ..(2).. ;

ある変数ZOTを定義するときは、

    VARIABLE ZOT

と書く。これでワードサイズの変数ZOTができる。

(1)の部分で、ZOTの中を作り、(2)の部分はZOTを呼び出したとき(使うとき)実行されるコードを決める。

変数の仕事は、

* 変数ZOTの値を確保する場所はパラメータフィールドである。
* ZOTを呼び出すと格納場所(パラメータフィールドのアドレス)を返す。

これだけである。参照と代入は@, !を用いる。

## `DOES>`の実装

コンパイル時動作と実行時動作を持つ定義ワードの構成方法。Forth Programmming Handbook に記載がある。以下示す。

<img src="img/020-structures-defined-by-using-does.png">

> 1. コンパイラは `DOES>`を実行します。`DOES>`のコンパイル時の動作は、定義される新しいワード(`DOES>`を含む定義ワードのインスタンス)のコードフィールドを設定するコードをコンパイルして、`(;CODE)`のコンパイルされたアドレスに続くセルを指すようにすることです。
> 2. `(;CODE)`のアドレスの後、`DOES>`は `DOES>`のランタイムコードへのサブルーチン呼び出しをコンパイルします。その後、コンパイラは新しい定義ワードのアドレスのコンパイルを終了します。(定義ワードのサブルーチン呼び出しの使用はシステムに依存します。しかし、`DOES>`のすべての実装は、定義ワードのデータ空間アドレスを失うことなく、`DOES>`のランタイムコードが定義ワードの高レベルコードを見つけられるように、定義ワードに何かをコンパイルします)。新しい定義ワードが実行されるとき、その最後のステップは、それが作成するエントリの実行トークンを、定義ワードの `DOES>`によって作成されたジャンプ・ツー・サブルーチンを指すように変更することです。
> 3. 新しい定義ワードによって作成されたインスタンスの 1 つが実行されると、仮想マシンは定義ワードのサブルーチン呼び出しにジャンプします。次に、サブルーチンコールは、CPU に依存する何らかの方法で、それ自体に続くセルのアドレスを保存し、`DOES>`の実行時コードにジャンプします。このコードは、サブルーチンリンケージからのアドレスを使って、定義ワードの実行トークンを見つけます。`DOES>`の実行時コードはまた、定義ワードのパラメータフィールドのアドレスをデータスタックにプッシュします。

`(CR)`のコードフィールドには、「スレッドコードを実行するルーチン」のアドレスが置かれる。スレッドコードを実行するルーチンなのだから、`COLON`に限りなく違いが、実行対象が、自ワードのパラメータフィールドではなく、元の定義ワードの`DOES>`の後ろ側という違いがある。

スタックトップにはワード`(CR)`のパラメータフィールドアドレスが置かれている。その前提で`DOES>`の後ろのスレッドが描かれている(`COUNT` `TYPE` の印字対象は`(CR)`のパラメータフィールドである 2 0D DAである)

```
1420 03     .head "MSG"
1421 4E
1422 54
1423 47
1424 20
1425 20
1426 XXYY   link
1428 XXXX   doList
142A XXXX   create
142C XXXX   dodoes  // (CR)コンパイル時の動作の終了
                    // 1428を(CR)のコードフィールドに書き込む
                    // SEMIをコンパイルして(CR)のエントリを締める
            doexit  // MSGのスレッドコードの終了
1428 142A   .+2     // code field (以下の機械語コードを実行)
142A C040   m_does  // DOES>の最初、
                    // WAを保存する(CR)のパラメータフィールドを
                    // 指しているので
                    // WAを使わずにdoLIST相当の処理を行う
                    // IPをリターンスタックに保存し、
                    // WAに142Cを入れてNEXTへジャンプする
                    // --> スレッドコード実行が始まる
142C XXXX   COUNT
142E XXXX   TYPE
1430 XXXX   exit
```

`DOES>`は即時ワードで、

* ワード`dodoes`をコンパイルする。
  + ワード`dodoes`は、
    * 生成中のワードのコードフィールドに1428を書き込む
    * 生成中のワードに`doexit`をコンパイルして締める
* ワード`doexit(or SEMI)`をコンパイルする
* .+2 をコンパイルする
* 機械語命令`m_does`をコンパイルする

以後の COUNT, TYPE, exitは通常のコンパイル処理で生成される。特に配慮は不要。

## 最小opcode

消しまくってERRORが出なくなるまで復活させる。

## base.f 作成スタート

ForthでForthシステムを書く、を開始した。Forthで必要なワードをopcodeで提供されるプリミティブを使い記述してゆく。

* 定数。メモリマップ、セルサイズCELLS, ユーザ変数(LAST, H, S0, STATE, BASE, HALT, COLON, SEMI, LITERAL, DOCONS)
  + LAST, H, S0, STATE, BASE: Forthプログラムの定番、外部インタプリタとコンパイル機能作成時に使う。
  + here, allot, last, immediate, `,`(comma)はこれを使い作成できた。
  + HALT, ワードhaltのxtを格納する、コンパイルで必要
  + COLON, SEMI, LITERAL, DOCONS: コンパイルに辞書エントリ(スレッドコードのリスト)に書き込む際に用いる。毎回文字列から辞書引くのもあれなので、それぞれユーザ変数にxt(またはコードフィールドに書き込むアドレス)を保持しておく。
* 制御構造
  + `<mark`, `<resolve`, `>mark`, `>resolvc`: 制御構造のジャンプ(スレッドリスト内での前後移動のオペランド書き込みに用いる。
  + if-then-else: mark/resolveワードを作っておけば、以前作ったこともありスムーズに動作させることができた。
  + do ... loop: これは難儀した、以下、記録を残しておく。

## do ... loop の作成

リターンスタックにループ変数を取る。末尾のループで、ループ変数の値とリミット値を比較して回るか抜けるかを決める。コンパイル時に、loop内部のジャンプ命令のオペランドを算出する。`<mark`, `<resolve`を doの定義、loopの定義で使う。

do ... loop はあるワードの定義中で使用する。そのワードのコンパイル中に

* do, i, loopの処理(i: ループ変数の値をスタックに載せる, loop:回るか抜けるか決める, 終了時のリターンスタック/データスタック後始末)を行うワードをコンパイルする。
* loop末尾からdoの次へのジャンプ命令とオペランドのコンパイル。オペランド計算をここで行うのも当然だが。

* ターゲットワードのコンパイル中に do, i, loop のxtをコンパイルしてしまうと、オペランド計算ができない。それだけはコンパイル中に「実行」する必要がある。
* do, loopでは、`<mark`, `<resolve`だけを実行し、他の xtをコンパイルする。
* iはとりあえずxtコンパイルでよいだろう。
* do, loopは即値属性を付けてコンパイル中に実行することとせざるを得ない。これで`<mark`, `<resolve`は実行できるが、これ以外のワード、リテラルはすべて「手でコンパイル」しなければならない。
* 手でコンパイル: `literal foo ,`がすべてのワードfooについて書き下ろす。これは大変面倒くさい。

do, loopを他のワードで書く方法はすでにあるはず。それを探してみる。

## do ... loop の実装例

eForthあたりかな。eForthは`FOR...NEXT`(NEXTはR@をデクリメントして0になれば抜ける)を使い、`DO...LOOP`系はない。

ふと思いついたのだが、ワード`(loop)`

    (loop) (limit iaddr index delta)

を作ればよさそう。limitはDO呼び出し前に置いたものをそのまま使う。LOOP系の中で、delta, index-addr (RSPを置く) を(実行時生成するようなコードをコンパイルして)、(loop)をターゲットワードにコンパイルする、その後ろに `compile jz <resolve`(jzをコンパイルしてオペランドを解決)すればよい。

    : (loop)         \ ( limit limit iaddr index delta -- limit flag )
        +            \ limit limit iaddr i+d
        dup rot      \ limit limit i+d i+d iaddr
        !            \ limit limit i+d
        swap >       \ (limit -1) if i+d > limit, (limit 0) if i+d <= limit 
        \ falling down to jz
        ;

    : loop  \ limit -- limit if loop remains | none if loop exits)
        compile dup         \ limit limit
        compile rsp         \ limit limit iaddr
        compile dup         \ limit limit iaddr iaddr
        compile @           \ limit limit iaddr index
        compile literal
        1 here ! cells allot   \ compile 1 as delta)
                            \ limit limit iaddr index 1 
        compile (loop)      \ limit -1|0
        compile jz
        <resolve
        compile r>          \ limit tors
        compile drop
        compile drop        \ discard index (at rsp) and limit
        ; immediate

かなり遅そう。C言語プリミティブで書いた方がよさそう。

## do ... loop デバッグ

かなり苦労した。がなんとかできた。

    : aho 3 1 do i . loop ;

が動くようになった。ちなみに

    : aho 3 1 do i loop ;

は動かない。loopに入るときは、doを出たときと同じスタックレベル(tosが 3)である必要があるためである。

* `do`, `loop`は、`<mark`, `<resolve` を呼び出し元ワードコンパイル時に実行せねばならないので、コンパイルしてしまってはいけない。これのために即値ワードにせねばならない。これ以外のワードはすべて`compile`を前に置く。
* `compile` は後ろのトークンをHに書き込む
* `r>`, `>r` は、rstackのpeekではなく、pushr/poprする。

## 即時ワードの実行の様子

即時ワードは、他のワードの定義中に実行される。COMPILEを使うとき、他のワードの定義に実行トークンを足してゆく。この時内部インタプリタが実行の主体である。一方で即時ワード自身の定義は、外部インタプリタがワード文字列から実行トークンを探し出して書き込んでゆく。

loopの定義では、前処理と後処理の間に jzワードを置かねばならない。jzワードを置いた次に`<resolve`を(他のワードのコンパイル中に)「実行」せねばならないので、loop自体を即時ワードとせねばならない。なんとなれば、ワードloopの実行トークンがターゲットワードのスレッド内に置かれてしまい、そのスレッドの中で実行したい`<resolve`が現れてこない。

`<resolve`以外のワードはすべて、ターゲットワード実行時に実行されるようにするために、それらワード全ての前に`compile`が置かれる。非常に見苦しい形になる。`if`, `eise`, `then`なら2ワード3ワードなので単純明快だが、`loop`のように10ワード以上も並ぶと分かりにくい。

`loop`１ワードだけをコンパイルし、かつ、条件付きジャンプを実現する方法として、`loop`の後ろに飛び先オペランドを置く、`loop`をオペランド付きワードとする方法もある。

今回は素直にcompile地獄で固めた。

## do ... loop 作り直し

最初のバージョンでは、limitをデータスタックに残し、indexだけをリターンスタックに置いていた。Forth79を見ると、limit, indexの2つともリターンスタックに置いてもよい、置くのが普通だ、と言っているように見えた。

> loop-sys: loop control parameters.  These include implementation-dependent representations of the current value of the loop index, its upper limit, and a pointer to a termination location where execution continues following an exit from the loop.

私の実装では、loop control parametersをリターンスタックに置いている。なので、limitもまとめておいても良さそうなので。

終端点のポインタもあり得るというのは面白い。上で書いたように、コンパイル中のスレッドコードでloopの次の位置を指す場所を使うこともありだろう。今回は、loopは即時ワードとして`<resolve`でブランチワードのオペランドを計算させているので不要だが、そういう手もあるとは考えていたし、実際に使うことがあると分かったのは収穫だった。

制御構造は

    if ... then
    if ... else ... then
    do ... loop
    begin ... until
    begin ... while ... repeat

まで作った。次に何を作るか。

## DOES> ... 定義語を定義できるようにしよう

定義語を定義するときは、

* 定義語を定義するときの手続き
* 新しくできた個々の定義語が実行されるときの手続き

の2種類があり、それをコロン定義するための仕掛けが `DOES>`である。

    : foo create ..(a).. does> ..(b).. ;

(a)の部分が foo xxx で xxxを定義するときに実行する処理で、(b)の部分が出来上がった xxx を実行するときの処理である。

例えば定義語 variable の場合、

    variable xxx

(a): 辞書上に名前xxxを持つエントリヘッドを作成し、1ワード分の空きを作る。  
(b): 1ワード分の空き(パラメータフィールド)のアドレスをスタックに積んで帰る。

である。

    : variable
        create cells allot
        does> ;

(b)部分のコードに入ってくる時点でスタックトップにパラメータフィールドのアドレスがプッシュされているので、does> 節で何も書かなくてよいとなっている。

entry_123:
    .head "variable"
    .link entry_122
    .dw   do_colon
    .dw   do_create
    .
    .(a)
    .
    // DOES> part
    .dw   do_does
    .dw   do_semi        // end of part (a)
does_execpart:
    .dw   do_colon
    .
    .(b)
    .
    .dw   do_semi

does>は即時ワードで、do_does, do_semi, do_colonを(その定義語のスレッドに)コンパイルする。

do_doesは、その定義語の実行時にターゲットワードのコンパイル処理を行う。

* ターゲットワードの code fieldに、does_execpartアドレスを格納する

例えば、定数定義語 constantは、

    : constant
        create , does> @ ;

と書けるため、create の後、hはコードフィールドをスキップしてパラメータフィールドまで進めておく必要がある。

